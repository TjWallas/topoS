package tum.in.net.psn.log_topo.NetworkModels.GENERATED
// Generated by Isabelle on Wed Sep 11 17:22:16 2013
// src: NetworkModel_Library.thy


object HOL {

trait equal[A] {
  val `HOL.equal`: (A, A) => Boolean
}
def equal[A](a: A, b: A)(implicit A: equal[A]): Boolean = A.`HOL.equal`(a, b)

def eq[A : equal](a: A, b: A): Boolean = equal[A](a, b)

} /* object HOL */

object Fun {

def fun_upd[A : HOL.equal, B](f: A => B, a: A, b: B): A => B =
  (x: A) => (if (HOL.eq[A](x, a)) b else f(x))

} /* object Fun */

object Orderings {

trait ord[A] {
  val `Orderings.less_eq`: (A, A) => Boolean
  val `Orderings.less`: (A, A) => Boolean
}
def less_eq[A](a: A, b: A)(implicit A: ord[A]): Boolean =
  A.`Orderings.less_eq`(a, b)
def less[A](a: A, b: A)(implicit A: ord[A]): Boolean = A.`Orderings.less`(a, b)

def max[A : ord](a: A, b: A): A = (if (less_eq[A](a, b)) b else a)

trait preorder[A] extends ord[A] {
}

trait order[A] extends preorder[A] {
}

trait linorder[A] extends order[A] {
}

} /* object Orderings */

object Num {

abstract sealed class num
final case class One() extends num
final case class Bit0(a: num) extends num
final case class Bit1(a: num) extends num

} /* object Num */

object Code_Numeral {

implicit def ord_integer: Orderings.ord[BigInt] = new Orderings.ord[BigInt] {
  val `Orderings.less_eq` = (a: BigInt, b: BigInt) => a <= b
  val `Orderings.less` = (a: BigInt, b: BigInt) => a < b
}

def integer_of_nat(x0: Nat.nat): BigInt = x0 match {
  case Nat.Nata(x) => x
}

def nat_of_integer(k: BigInt): Nat.nat =
  Nat.Nata(Orderings.max[BigInt](BigInt(0), k))

} /* object Code_Numeral */

object Nat {

import /*implicits*/ Code_Numeral.ord_integer

abstract sealed class nat
final case class Nata(a: BigInt) extends nat {override def toString = a.toString}

def plus_nat(m: nat, n: nat): nat =
  Nata(Code_Numeral.integer_of_nat(m) + Code_Numeral.integer_of_nat(n))

def one_nat: nat = Nata(BigInt(1))

def suc(n: nat): nat = plus_nat(n, one_nat)

def less_nat(m: nat, n: nat): Boolean =
  Code_Numeral.integer_of_nat(m) < Code_Numeral.integer_of_nat(n)

def zero_nat: nat = Nata(BigInt(0))

def equal_nat(m: nat, n: nat): Boolean =
  Code_Numeral.integer_of_nat(m) == Code_Numeral.integer_of_nat(n)

def minus_nat(m: nat, n: nat): nat =
  Nata(Orderings.max[BigInt](BigInt(0),
                              Code_Numeral.integer_of_nat(m) -
                                Code_Numeral.integer_of_nat(n)))

def less_eq_nat(m: nat, n: nat): Boolean =
  Code_Numeral.integer_of_nat(m) <= Code_Numeral.integer_of_nat(n)

} /* object Nat */

object RBT_Impl {

abstract sealed class color
final case class R() extends color
final case class B() extends color

abstract sealed class rbt[A, B]
final case class Empty[A, B]() extends rbt[A, B]
final case class Branch[A, B](a: color, b: rbt[A, B], c: A, d: B, e: rbt[A, B])
  extends rbt[A, B]

def paint[A, B](c: color, x1: rbt[A, B]): rbt[A, B] = (c, x1) match {
  case (c, Empty()) => Empty[A, B]()
  case (c, Branch(uu, l, k, v, r)) => Branch[A, B](c, l, k, v, r)
}

def balance[A, B](x0: rbt[A, B], s: A, t: B, x3: rbt[A, B]): rbt[A, B] =
  (x0, s, t, x3) match {
  case (Branch(R(), a, w, x, b), s, t, Branch(R(), c, y, z, d)) =>
    Branch[A, B](R(), Branch[A, B](B(), a, w, x, b), s, t,
                  Branch[A, B](B(), c, y, z, d))
  case (Branch(R(), Branch(R(), a, w, x, b), s, t, c), y, z, Empty()) =>
    Branch[A, B](R(), Branch[A, B](B(), a, w, x, b), s, t,
                  Branch[A, B](B(), c, y, z, Empty[A, B]()))
  case (Branch(R(), Branch(R(), a, w, x, b), s, t, c), y, z,
         Branch(B(), va, vb, vc, vd))
    => Branch[A, B](R(), Branch[A, B](B(), a, w, x, b), s, t,
                     Branch[A, B](B(), c, y, z,
                                   Branch[A, B](B(), va, vb, vc, vd)))
  case (Branch(R(), Empty(), w, x, Branch(R(), b, s, t, c)), y, z, Empty()) =>
    Branch[A, B](R(), Branch[A, B](B(), Empty[A, B](), w, x, b), s, t,
                  Branch[A, B](B(), c, y, z, Empty[A, B]()))
  case (Branch(R(), Branch(B(), va, vb, vc, vd), w, x, Branch(R(), b, s, t, c)),
         y, z, Empty())
    => Branch[A, B](R(), Branch[A, B](B(), Branch[A, B](B(), va, vb, vc, vd), w,
                                       x, b),
                     s, t, Branch[A, B](B(), c, y, z, Empty[A, B]()))
  case (Branch(R(), Empty(), w, x, Branch(R(), b, s, t, c)), y, z,
         Branch(B(), va, vb, vc, vd))
    => Branch[A, B](R(), Branch[A, B](B(), Empty[A, B](), w, x, b), s, t,
                     Branch[A, B](B(), c, y, z,
                                   Branch[A, B](B(), va, vb, vc, vd)))
  case (Branch(R(), Branch(B(), ve, vf, vg, vh), w, x, Branch(R(), b, s, t, c)),
         y, z, Branch(B(), va, vb, vc, vd))
    => Branch[A, B](R(), Branch[A, B](B(), Branch[A, B](B(), ve, vf, vg, vh), w,
                                       x, b),
                     s, t,
                     Branch[A, B](B(), c, y, z,
                                   Branch[A, B](B(), va, vb, vc, vd)))
  case (Empty(), w, x, Branch(R(), b, s, t, Branch(R(), c, y, z, d))) =>
    Branch[A, B](R(), Branch[A, B](B(), Empty[A, B](), w, x, b), s, t,
                  Branch[A, B](B(), c, y, z, d))
  case (Branch(B(), va, vb, vc, vd), w, x,
         Branch(R(), b, s, t, Branch(R(), c, y, z, d)))
    => Branch[A, B](R(), Branch[A, B](B(), Branch[A, B](B(), va, vb, vc, vd), w,
                                       x, b),
                     s, t, Branch[A, B](B(), c, y, z, d))
  case (Empty(), w, x, Branch(R(), Branch(R(), b, s, t, c), y, z, Empty())) =>
    Branch[A, B](R(), Branch[A, B](B(), Empty[A, B](), w, x, b), s, t,
                  Branch[A, B](B(), c, y, z, Empty[A, B]()))
  case (Empty(), w, x,
         Branch(R(), Branch(R(), b, s, t, c), y, z,
                 Branch(B(), va, vb, vc, vd)))
    => Branch[A, B](R(), Branch[A, B](B(), Empty[A, B](), w, x, b), s, t,
                     Branch[A, B](B(), c, y, z,
                                   Branch[A, B](B(), va, vb, vc, vd)))
  case (Branch(B(), va, vb, vc, vd), w, x,
         Branch(R(), Branch(R(), b, s, t, c), y, z, Empty()))
    => Branch[A, B](R(), Branch[A, B](B(), Branch[A, B](B(), va, vb, vc, vd), w,
                                       x, b),
                     s, t, Branch[A, B](B(), c, y, z, Empty[A, B]()))
  case (Branch(B(), va, vb, vc, vd), w, x,
         Branch(R(), Branch(R(), b, s, t, c), y, z,
                 Branch(B(), ve, vf, vg, vh)))
    => Branch[A, B](R(), Branch[A, B](B(), Branch[A, B](B(), va, vb, vc, vd), w,
                                       x, b),
                     s, t,
                     Branch[A, B](B(), c, y, z,
                                   Branch[A, B](B(), ve, vf, vg, vh)))
  case (Empty(), s, t, Empty()) =>
    Branch[A, B](B(), Empty[A, B](), s, t, Empty[A, B]())
  case (Empty(), s, t, Branch(B(), va, vb, vc, vd)) =>
    Branch[A, B](B(), Empty[A, B](), s, t, Branch[A, B](B(), va, vb, vc, vd))
  case (Empty(), s, t, Branch(v, Empty(), vb, vc, Empty())) =>
    Branch[A, B](B(), Empty[A, B](), s, t,
                  Branch[A, B](v, Empty[A, B](), vb, vc, Empty[A, B]()))
  case (Empty(), s, t, Branch(v, Branch(B(), ve, vf, vg, vh), vb, vc, Empty()))
    => Branch[A, B](B(), Empty[A, B](), s, t,
                     Branch[A, B](v, Branch[A, B](B(), ve, vf, vg, vh), vb, vc,
                                   Empty[A, B]()))
  case (Empty(), s, t, Branch(v, Empty(), vb, vc, Branch(B(), vf, vg, vh, vi)))
    => Branch[A, B](B(), Empty[A, B](), s, t,
                     Branch[A, B](v, Empty[A, B](), vb, vc,
                                   Branch[A, B](B(), vf, vg, vh, vi)))
  case (Empty(), s, t,
         Branch(v, Branch(B(), ve, vj, vk, vl), vb, vc,
                 Branch(B(), vf, vg, vh, vi)))
    => Branch[A, B](B(), Empty[A, B](), s, t,
                     Branch[A, B](v, Branch[A, B](B(), ve, vj, vk, vl), vb, vc,
                                   Branch[A, B](B(), vf, vg, vh, vi)))
  case (Branch(B(), va, vb, vc, vd), s, t, Empty()) =>
    Branch[A, B](B(), Branch[A, B](B(), va, vb, vc, vd), s, t, Empty[A, B]())
  case (Branch(B(), va, vb, vc, vd), s, t, Branch(B(), ve, vf, vg, vh)) =>
    Branch[A, B](B(), Branch[A, B](B(), va, vb, vc, vd), s, t,
                  Branch[A, B](B(), ve, vf, vg, vh))
  case (Branch(B(), va, vb, vc, vd), s, t, Branch(v, Empty(), vf, vg, Empty()))
    => Branch[A, B](B(), Branch[A, B](B(), va, vb, vc, vd), s, t,
                     Branch[A, B](v, Empty[A, B](), vf, vg, Empty[A, B]()))
  case (Branch(B(), va, vb, vc, vd), s, t,
         Branch(v, Branch(B(), vi, vj, vk, vl), vf, vg, Empty()))
    => Branch[A, B](B(), Branch[A, B](B(), va, vb, vc, vd), s, t,
                     Branch[A, B](v, Branch[A, B](B(), vi, vj, vk, vl), vf, vg,
                                   Empty[A, B]()))
  case (Branch(B(), va, vb, vc, vd), s, t,
         Branch(v, Empty(), vf, vg, Branch(B(), vj, vk, vl, vm)))
    => Branch[A, B](B(), Branch[A, B](B(), va, vb, vc, vd), s, t,
                     Branch[A, B](v, Empty[A, B](), vf, vg,
                                   Branch[A, B](B(), vj, vk, vl, vm)))
  case (Branch(B(), va, vb, vc, vd), s, t,
         Branch(v, Branch(B(), vi, vn, vo, vp), vf, vg,
                 Branch(B(), vj, vk, vl, vm)))
    => Branch[A, B](B(), Branch[A, B](B(), va, vb, vc, vd), s, t,
                     Branch[A, B](v, Branch[A, B](B(), vi, vn, vo, vp), vf, vg,
                                   Branch[A, B](B(), vj, vk, vl, vm)))
  case (Branch(v, Empty(), vb, vc, Empty()), s, t, Empty()) =>
    Branch[A, B](B(), Branch[A, B](v, Empty[A, B](), vb, vc, Empty[A, B]()), s,
                  t, Empty[A, B]())
  case (Branch(v, Empty(), vb, vc, Branch(B(), ve, vf, vg, vh)), s, t, Empty())
    => Branch[A, B](B(), Branch[A, B](v, Empty[A, B](), vb, vc,
                                       Branch[A, B](B(), ve, vf, vg, vh)),
                     s, t, Empty[A, B]())
  case (Branch(v, Branch(B(), vf, vg, vh, vi), vb, vc, Empty()), s, t, Empty())
    => Branch[A, B](B(), Branch[A, B](v, Branch[A, B](B(), vf, vg, vh, vi), vb,
                                       vc, Empty[A, B]()),
                     s, t, Empty[A, B]())
  case (Branch(v, Branch(B(), vf, vg, vh, vi), vb, vc,
                Branch(B(), ve, vj, vk, vl)),
         s, t, Empty())
    => Branch[A, B](B(), Branch[A, B](v, Branch[A, B](B(), vf, vg, vh, vi), vb,
                                       vc, Branch[A, B](B(), ve, vj, vk, vl)),
                     s, t, Empty[A, B]())
  case (Branch(v, Empty(), vf, vg, Empty()), s, t, Branch(B(), va, vb, vc, vd))
    => Branch[A, B](B(), Branch[A, B](v, Empty[A, B](), vf, vg, Empty[A, B]()),
                     s, t, Branch[A, B](B(), va, vb, vc, vd))
  case (Branch(v, Empty(), vf, vg, Branch(B(), vi, vj, vk, vl)), s, t,
         Branch(B(), va, vb, vc, vd))
    => Branch[A, B](B(), Branch[A, B](v, Empty[A, B](), vf, vg,
                                       Branch[A, B](B(), vi, vj, vk, vl)),
                     s, t, Branch[A, B](B(), va, vb, vc, vd))
  case (Branch(v, Branch(B(), vj, vk, vl, vm), vf, vg, Empty()), s, t,
         Branch(B(), va, vb, vc, vd))
    => Branch[A, B](B(), Branch[A, B](v, Branch[A, B](B(), vj, vk, vl, vm), vf,
                                       vg, Empty[A, B]()),
                     s, t, Branch[A, B](B(), va, vb, vc, vd))
  case (Branch(v, Branch(B(), vj, vk, vl, vm), vf, vg,
                Branch(B(), vi, vn, vo, vp)),
         s, t, Branch(B(), va, vb, vc, vd))
    => Branch[A, B](B(), Branch[A, B](v, Branch[A, B](B(), vj, vk, vl, vm), vf,
                                       vg, Branch[A, B](B(), vi, vn, vo, vp)),
                     s, t, Branch[A, B](B(), va, vb, vc, vd))
}

def rbt_ins[A : Orderings.ord,
             B](f: A => B => B => B, k: A, v: B, x3: rbt[A, B]):
      rbt[A, B] =
  (f, k, v, x3) match {
  case (f, k, v, Empty()) =>
    Branch[A, B](R(), Empty[A, B](), k, v, Empty[A, B]())
  case (f, k, v, Branch(B(), l, x, y, r)) =>
    (if (Orderings.less[A](k, x))
      balance[A, B](rbt_ins[A, B](f, k, v, l), x, y, r)
      else (if (Orderings.less[A](x, k))
             balance[A, B](l, x, y, rbt_ins[A, B](f, k, v, r))
             else Branch[A, B](B(), l, x, ((f(k))(y))(v), r)))
  case (f, k, v, Branch(R(), l, x, y, r)) =>
    (if (Orderings.less[A](k, x))
      Branch[A, B](R(), rbt_ins[A, B](f, k, v, l), x, y, r)
      else (if (Orderings.less[A](x, k))
             Branch[A, B](R(), l, x, y, rbt_ins[A, B](f, k, v, r))
             else Branch[A, B](R(), l, x, ((f(k))(y))(v), r)))
}

def rbt_insert_with_key[A : Orderings.ord,
                         B](f: A => B => B => B, k: A, v: B, t: rbt[A, B]):
      rbt[A, B] =
  paint[A, B](B(), rbt_ins[A, B](f, k, v, t))

def rbt_insert[A : Orderings.ord, B]: A => B => (rbt[A, B]) => rbt[A, B] =
  (a: A) =>
    (b: B) =>
      (c: rbt[A, B]) =>
        rbt_insert_with_key[A, B]((_: A) => (_: B) => (nv: B) => nv, a, b, c)

def rbt_lookup[A : Orderings.ord, B](x0: rbt[A, B], k: A): Option[B] = (x0, k)
  match {
  case (Empty(), k) => None
  case (Branch(uu, l, x, y, r), k) =>
    (if (Orderings.less[A](k, x)) rbt_lookup[A, B](l, k)
      else (if (Orderings.less[A](x, k)) rbt_lookup[A, B](r, k)
             else Some[B](y)))
}

} /* object RBT_Impl */

object RBT {

abstract sealed class rbt[A, B]
final case class Rbt[A, B](a: RBT_Impl.rbt[A, B]) extends rbt[A, B]

def empty[A : Orderings.linorder, B]: rbt[A, B] =
  Rbt[A, B](RBT_Impl.Empty[A, B]())

def impl_of[A : Orderings.linorder, B](x0: rbt[A, B]): RBT_Impl.rbt[A, B] = x0
  match {
  case Rbt(x) => x
}

def insert[A : Orderings.linorder, B](x: A, xa: B, xb: rbt[A, B]): rbt[A, B] =
  Rbt[A, B](RBT_Impl.rbt_insert[A, B].apply(x).apply(xa).apply(impl_of[A,
                                B](xb)))

def lookup[A : Orderings.linorder, B](x: rbt[A, B]): A => Option[B] =
  (a: A) => RBT_Impl.rbt_lookup[A, B](impl_of[A, B](x), a)

} /* object RBT */

object Product_Type {

def snd[A, B](x0: (A, B)): B = x0 match {
  case (a, b) => b
}

def equal_proda[A : HOL.equal, B : HOL.equal](x0: (A, B), x1: (A, B)): Boolean =
  (x0, x1) match {
  case ((aa, ba), (a, b)) => HOL.eq[A](aa, a) && HOL.eq[B](ba, b)
}

implicit def equal_prod[A : HOL.equal, B : HOL.equal]: HOL.equal[(A, B)] = new
  HOL.equal[(A, B)] {
  val `HOL.equal` = (a: (A, B), b: (A, B)) => equal_proda[A, B](a, b)
}

} /* object Product_Type */

object Misc {

def less_eq_prod_aux[A : HOL.equal : Orderings.ord,
                      B : Orderings.ord](x0: (A, B), x1: (A, B)):
      Boolean =
  (x0, x1) match {
  case ((a1, a2), (b1, b2)) =>
    Orderings.less[A](a1, b1) ||
      HOL.eq[A](a1, b1) && Orderings.less_eq[B](a2, b2)
}

def less_eq_prod[A : HOL.equal : Orderings.ord,
                  B : Orderings.ord](a: (A, B), b: (A, B)):
      Boolean =
  less_eq_prod_aux[A, B](a, b)

def less_prod[A : HOL.equal : Orderings.ord,
               B : HOL.equal : Orderings.ord](a: (A, B), b: (A, B)):
      Boolean =
  ! (Product_Type.equal_proda[A, B](a, b)) && less_eq_prod_aux[A, B](a, b)

implicit def
  ord_prod[A : HOL.equal : Orderings.ord, B : HOL.equal : Orderings.ord]:
    Orderings.ord[(A, B)]
  = new Orderings.ord[(A, B)] {
  val `Orderings.less_eq` = (a: (A, B), b: (A, B)) => less_eq_prod[A, B](a, b)
  val `Orderings.less` = (a: (A, B), b: (A, B)) => less_prod[A, B](a, b)
}

implicit def
  preorder_prod[A : HOL.equal : Orderings.order,
                 B : HOL.equal : Orderings.order]:
    Orderings.preorder[(A, B)]
  = new Orderings.preorder[(A, B)] {
  val `Orderings.less_eq` = (a: (A, B), b: (A, B)) => less_eq_prod[A, B](a, b)
  val `Orderings.less` = (a: (A, B), b: (A, B)) => less_prod[A, B](a, b)
}

implicit def
  order_prod[A : HOL.equal : Orderings.order, B : HOL.equal : Orderings.order]:
    Orderings.order[(A, B)]
  = new Orderings.order[(A, B)] {
  val `Orderings.less_eq` = (a: (A, B), b: (A, B)) => less_eq_prod[A, B](a, b)
  val `Orderings.less` = (a: (A, B), b: (A, B)) => less_prod[A, B](a, b)
}

implicit def
  linorder_prod[A : HOL.equal : Orderings.linorder,
                 B : HOL.equal : Orderings.linorder]:
    Orderings.linorder[(A, B)]
  = new Orderings.linorder[(A, B)] {
  val `Orderings.less_eq` = (a: (A, B), b: (A, B)) => less_eq_prod[A, B](a, b)
  val `Orderings.less` = (a: (A, B), b: (A, B)) => less_prod[A, B](a, b)
}

} /* object Misc */

object Optiona {

def is_none[A](x0: Option[A]): Boolean = x0 match {
  case Some(x) => false
  case None => true
}

} /* object Optiona */

object ListAdd {

def merge[A : HOL.equal : Orderings.linorder](as: List[A], bs: List[A]):
      List[A] =
  Efficient_Distinct.merge_tailrec[A](as, bs, Nil)

def merge_list[A : HOL.equal : Orderings.linorder](acc2: List[List[A]],
            x1: List[List[A]]):
      List[A] =
  (acc2, x1) match {
  case (Nil, Nil) => Nil
  case (Nil, List(l)) => l
  case (la :: acc2, Nil) => merge_list[A](Nil, la :: acc2)
  case (la :: acc2, List(l)) => merge_list[A](Nil, l :: la :: acc2)
  case (acc2, l1 :: l2 :: ls) => merge_list[A](merge[A](l1, l2) :: acc2, ls)
}

def mergesort[A : HOL.equal : Orderings.linorder](xs: List[A]): List[A] =
  merge_list[A](Nil, Lista.map[A, List[A]]((x: A) => List(x), xs))

} /* object ListAdd */

object Efficient_Distinct {

def map_tailrec[A, B](f: A => B, x1: List[A], accs: List[B]): List[B] =
  (f, x1, accs) match {
  case (f, Nil, accs) => accs
  case (f, a :: as, accs) => map_tailrec[A, B](f, as, f(a) :: accs)
}

def efficient_map[A, B](f: A => B, l: List[A]): List[B] =
  Lista.rev[B](map_tailrec[A, B](f, l, Nil))

def merge_tailrec[A : HOL.equal : Orderings.linorder](x0: List[A], bs: List[A],
               accs: List[A]):
      List[A] =
  (x0, bs, accs) match {
  case (a :: as, b :: bs, accs) =>
    (if (Orderings.less[A](a, b)) merge_tailrec[A](as, b :: bs, a :: accs)
      else (if (HOL.eq[A](a, b)) merge_tailrec[A](as, bs, a :: accs)
             else merge_tailrec[A](a :: as, bs, b :: accs)))
  case (Nil, bs, accs) => Lista.rev[A](accs) ++ bs
  case (v :: va, Nil, accs) => Lista.rev[A](accs) ++ (v :: va)
}

} /* object Efficient_Distinct */

object Lista {

def map[A, B](f: A => B, l: List[A]): List[B] =
  Efficient_Distinct.efficient_map[A, B](f, l)

def fold[A, B](f: A => B => B, x1: List[A], s: B): B = (f, x1, s) match {
  case (f, x :: xs, s) => fold[A, B](f, xs, (f(x))(s))
  case (f, Nil, s) => s
}

def rev[A](xs: List[A]): List[A] =
  fold[A, List[A]]((a: A) => (b: List[A]) => a :: b, xs, Nil)

def nulla[A](x0: List[A]): Boolean = x0 match {
  case Nil => true
  case x :: xs => false
}

def filter[A](p: A => Boolean, x1: List[A]): List[A] = (p, x1) match {
  case (p, Nil) => Nil
  case (p, x :: xs) => (if (p(x)) x :: filter[A](p, xs) else filter[A](p, xs))
}

def member[A : HOL.equal](x0: List[A], y: A): Boolean = (x0, y) match {
  case (Nil, y) => false
  case (x :: xs, y) => HOL.eq[A](x, y) || member[A](xs, y)
}

def remdups[A : HOL.equal](x0: List[A]): List[A] = x0 match {
  case Nil => Nil
  case x :: xs =>
    (if (member[A](xs, x)) remdups[A](xs) else x :: remdups[A](xs))
}

def remove1[A : HOL.equal](x: A, xa1: List[A]): List[A] = (x, xa1) match {
  case (x, Nil) => Nil
  case (x, y :: xs) => (if (HOL.eq[A](x, y)) xs else y :: remove1[A](x, xs))
}

def gen_length[A](n: Nat.nat, x1: List[A]): Nat.nat = (n, x1) match {
  case (n, x :: xs) => gen_length[A](Nat.suc(n), xs)
  case (n, Nil) => n
}

def size_list[A]: (List[A]) => Nat.nat =
  (a: List[A]) => gen_length[A](Nat.zero_nat, a)

def distinct[A : HOL.equal : Orderings.linorder](xs: List[A]): Boolean =
  Nat.equal_nat(size_list[A].apply(ListAdd.mergesort[A](xs)),
                 size_list[A].apply(xs))

def list_all[A](p: A => Boolean, x1: List[A]): Boolean = (p, x1) match {
  case (p, Nil) => true
  case (p, x :: xs) => p(x) && list_all[A](p, xs)
}

def sublists[A](x0: List[A]): List[List[A]] = x0 match {
  case Nil => List(Nil)
  case x :: xs =>
    {
      val xss: List[List[A]] = sublists[A](xs);
      map[List[A], List[A]]((a: List[A]) => x :: a, xss) ++ xss
    }
}

def removeAll[A : HOL.equal](x: A, xa1: List[A]): List[A] = (x, xa1) match {
  case (x, Nil) => Nil
  case (x, y :: xs) =>
    (if (HOL.eq[A](x, y)) removeAll[A](x, xs) else y :: removeAll[A](x, xs))
}

def equal_list[A : HOL.equal](x0: List[A], x1: List[A]): Boolean = (x0, x1)
  match {
  case (a :: list, Nil) => false
  case (Nil, a :: list) => false
  case (aa :: lista, a :: list) =>
    HOL.eq[A](aa, a) && equal_list[A](lista, list)
  case (Nil, Nil) => true
}

def map_filter[A, B](f: A => Option[B], x1: List[A]): List[B] = (f, x1) match {
  case (f, Nil) => Nil
  case (f, x :: xs) =>
    (f(x) match {
       case None => map_filter[A, B](f, xs)
       case Some(y) => y :: map_filter[A, B](f, xs)
     })
}

} /* object Lista */

object SetGA {

def gen_list_to_set_aux[A, B](ins: A => B => B, accs: B, x2: List[A]): B =
  (ins, accs, x2) match {
  case (ins, accs, Nil) => accs
  case (ins, accs, x :: l) => gen_list_to_set_aux[A, B](ins, (ins(x))(accs), l)
}

def gen_list_to_set[A, B](empt: Unit => A, ins: B => A => A): (List[B]) => A =
  (a: List[B]) => gen_list_to_set_aux[B, A](ins, empt(()), a)

} /* object SetGA */

object String {

abstract sealed class nibble
final case class Nibble0() extends nibble
final case class Nibble1() extends nibble
final case class Nibble2() extends nibble
final case class Nibble3() extends nibble
final case class Nibble4() extends nibble
final case class Nibble5() extends nibble
final case class Nibble6() extends nibble
final case class Nibble7() extends nibble
final case class Nibble8() extends nibble
final case class Nibble9() extends nibble
final case class NibbleA() extends nibble
final case class NibbleB() extends nibble
final case class NibbleC() extends nibble
final case class NibbleD() extends nibble
final case class NibbleE() extends nibble
final case class NibbleF() extends nibble

implicit def equal_char: HOL.equal[Char] = new HOL.equal[Char] {
  val `HOL.equal` = (a: Char, b: Char) => a == b
}

} /* object String */

object List_lexord {

def less_list[A : HOL.equal : Orderings.order](xs: List[A], x1: List[A]):
      Boolean =
  (xs, x1) match {
  case (x :: xs, y :: ys) =>
    Orderings.less[A](x, y) || HOL.eq[A](x, y) && less_list[A](xs, ys)
  case (Nil, x :: xs) => true
  case (xs, Nil) => false
}

def less_eq_list[A : HOL.equal : Orderings.order](x0: List[A], xs: List[A]):
      Boolean =
  (x0, xs) match {
  case (x :: xs, y :: ys) =>
    Orderings.less[A](x, y) || HOL.eq[A](x, y) && less_eq_list[A](xs, ys)
  case (Nil, xs) => true
  case (x :: xs, Nil) => false
}

} /* object List_lexord */

object Char_ord {

implicit def ord_char: Orderings.ord[Char] = new Orderings.ord[Char] {
  val `Orderings.less_eq` = (a: Char, b: Char) => a <= b
  val `Orderings.less` = (a: Char, b: Char) => a < b
}

implicit def preorder_char: Orderings.preorder[Char] = new
  Orderings.preorder[Char] {
  val `Orderings.less_eq` = (a: Char, b: Char) => a <= b
  val `Orderings.less` = (a: Char, b: Char) => a < b
}

implicit def order_char: Orderings.order[Char] = new Orderings.order[Char] {
  val `Orderings.less_eq` = (a: Char, b: Char) => a <= b
  val `Orderings.less` = (a: Char, b: Char) => a < b
}

} /* object Char_ord */

object NetworkModel_Vertices {

import /*implicits*/ Char_ord.order_char, String.equal_char

abstract sealed class vString
final case class V(a: List[Char]) extends vString

trait vertex[A] {
  val `NetworkModel_Vertices.vertex_1`: A
  val `NetworkModel_Vertices.vertex_2`: A
  val `NetworkModel_Vertices.vertex_3`: A
}
def vertex_1[A](implicit A: vertex[A]): A = A.`NetworkModel_Vertices.vertex_1`
def vertex_2[A](implicit A: vertex[A]): A = A.`NetworkModel_Vertices.vertex_2`
def vertex_3[A](implicit A: vertex[A]): A = A.`NetworkModel_Vertices.vertex_3`

def string_of_vString(v: vString): List[Char] = {
          val (V(s)): vString = v;
          s
        }

def less_eq_vString(a: vString, b: vString): Boolean =
  List_lexord.less_eq_list[Char](string_of_vString(a), string_of_vString(b))

def less_vString(a: vString, b: vString): Boolean =
  List_lexord.less_list[Char](string_of_vString(a), string_of_vString(b))

implicit def ord_vString: Orderings.ord[vString] = new Orderings.ord[vString] {
  val `Orderings.less_eq` = (a: vString, b: vString) => less_eq_vString(a, b)
  val `Orderings.less` = (a: vString, b: vString) => less_vString(a, b)
}

def equal_vStringa(x0: vString, x1: vString): Boolean = (x0, x1) match {
  case (V(lista), V(list)) => Lista.equal_list[Char](lista, list)
}

implicit def equal_vString: HOL.equal[vString] = new HOL.equal[vString] {
  val `HOL.equal` = (a: vString, b: vString) => equal_vStringa(a, b)
}

implicit def preorder_vString: Orderings.preorder[vString] = new
  Orderings.preorder[vString] {
  val `Orderings.less_eq` = (a: vString, b: vString) => less_eq_vString(a, b)
  val `Orderings.less` = (a: vString, b: vString) => less_vString(a, b)
}

implicit def order_vString: Orderings.order[vString] = new
  Orderings.order[vString] {
  val `Orderings.less_eq` = (a: vString, b: vString) => less_eq_vString(a, b)
  val `Orderings.less` = (a: vString, b: vString) => less_vString(a, b)
}

def vertex_3_vString: vString = V(List('C'))

def vertex_2_vString: vString = V(List('B'))

def vertex_1_vString: vString = V(List('A'))

implicit def vertex_vString: vertex[vString] = new vertex[vString] {
  val `NetworkModel_Vertices.vertex_1` = vertex_1_vString
  val `NetworkModel_Vertices.vertex_2` = vertex_2_vString
  val `NetworkModel_Vertices.vertex_3` = vertex_3_vString
}

implicit def linorder_vString: Orderings.linorder[vString] = new
  Orderings.linorder[vString] {
  val `Orderings.less_eq` = (a: vString, b: vString) => less_eq_vString(a, b)
  val `Orderings.less` = (a: vString, b: vString) => less_vString(a, b)
}

} /* object NetworkModel_Vertices */

object NetworkModel_Interface {

abstract sealed class networkModel_Params_ext[A, B, C, D]
final case class
  NetworkModel_Params_ext[A, B, C, D](a: A => Option[B], b: C, c: D)
  extends networkModel_Params_ext[A, B, C, D]

def node_properties[A : NetworkModel_Vertices.vertex, B, C,
                     D](x0: networkModel_Params_ext[A, B, C, D]):
      A => Option[B] =
  x0 match {
  case NetworkModel_Params_ext(node_properties, model_global_properties, more)
    => node_properties
}

def model_global_properties[A : NetworkModel_Vertices.vertex, B, C,
                             D](x0: networkModel_Params_ext[A, B, C, D]):
      C =
  x0 match {
  case NetworkModel_Params_ext(node_properties, model_global_properties, more)
    => model_global_properties
}

} /* object NetworkModel_Interface */

object Transitive_Closure_Impl {

def relpow_impl[A, B](succ: (List[A]) => List[A], un: (List[A]) => B => B,
                       memb: A => B => Boolean, newa: List[A], have: B,
                       m: Nat.nat):
      B =
  (if (Nat.equal_nat(m, Nat.zero_nat)) (un(newa))(have)
    else (if (Lista.nulla[A](newa)) have
           else {
                  val maybe: List[A] = succ(newa)
                  val havea: B = (un(newa))(have)
                  val newb: List[A] =
                    Lista.filter[A]((n: A) => ! ((memb(n))(havea)), maybe);
                  relpow_impl[A, B](succ, un, memb, newb, havea,
                                     Nat.minus_nat(m, Nat.one_nat))
                }))

def trancl_impl[A, B](gen_succ: (List[(A, A)]) => (List[A]) => List[A],
                       un: (List[A]) => B => B, memb: A => B => Boolean, emp: B,
                       rel: List[(A, A)]):
      (List[A]) => B =
  {
    val succ: (List[A]) => List[A] = gen_succ(rel)
    val n: Nat.nat = Lista.size_list[(A, A)].apply(rel);
    (as: List[A]) => relpow_impl[A, B](succ, un, memb, succ(as), emp, n)
  }

} /* object Transitive_Closure_Impl */

object Transitive_Closure_List_Impl {

def trancl_list_impl[A : HOL.equal]: (List[(A, A)]) => (List[A]) => List[A] =
  (a: List[(A, A)]) =>
    Transitive_Closure_Impl.trancl_impl[A,
 List[A]]((r: List[(A, A)]) =>
            (as: List[A]) =>
              Lista.remdups[A](Lista.map_filter[(A, A),
         A]((x: (A, A)) =>
              (if ({
                     val (aa, _): (A, A) = x;
                     Lista.member[A](as, aa)
                   })
                Some[A](Product_Type.snd[A, A](x)) else None),
             r)),
           (xs: List[A]) =>
             (ys: List[A]) =>
               Lista.filter[A]((x: A) => ! (Lista.member[A](ys, x)), xs) ++ ys,
           (x: A) => (xs: List[A]) => Lista.member[A](xs, x), Nil, a)

} /* object Transitive_Closure_List_Impl */

object RBTMapImpl {

def rm_empty[A : Orderings.linorder, B]: Unit => RBT.rbt[A, B] =
  (_: Unit) => RBT.empty[A, B]

def rm_lookup[A : Orderings.linorder, B](k: A, m: RBT.rbt[A, B]): Option[B] =
  (RBT.lookup[A, B](m)).apply(k)

def rm_update[A : Orderings.linorder, B]:
      A => B => (RBT.rbt[A, B]) => RBT.rbt[A, B] =
  (a: A) => (b: B) => (c: RBT.rbt[A, B]) => RBT.insert[A, B](a, b, c)

} /* object RBTMapImpl */

object SetByMap {

def s_ins[A, B, C](update: A => Unit => B => C, x: A, s: B): C =
  ((update(x))(()))(s)

def s_memb[A, B, C](lookup: A => B => Option[C], x: A, s: B): Boolean =
  ! (Optiona.is_none[C]((lookup(x))(s)))

} /* object SetByMap */

object RBTSetImpl {

def rs_ins[A : Orderings.linorder]:
      A => (RBT.rbt[A, Unit]) => RBT.rbt[A, Unit] =
  (a: A) =>
    (b: RBT.rbt[A, Unit]) =>
      SetByMap.s_ins[A, RBT.rbt[A, Unit],
                      RBT.rbt[A, Unit]](RBTMapImpl.rm_update[A, Unit], a, b)

def rs_memb[A : Orderings.linorder]: A => (RBT.rbt[A, Unit]) => Boolean =
  (a: A) =>
    (b: RBT.rbt[A, Unit]) =>
      SetByMap.s_memb[A, RBT.rbt[A, Unit],
                       Unit]((aa: A) =>
                               (ba: RBT.rbt[A, Unit]) =>
                                 RBTMapImpl.rm_lookup[A, Unit](aa, ba),
                              a, b)

def rs_empty[A : Orderings.linorder]: Unit => RBT.rbt[A, Unit] =
  RBTMapImpl.rm_empty[A, Unit]

def list_to_rs[A : Orderings.linorder]: (List[A]) => RBT.rbt[A, Unit] =
  SetGA.gen_list_to_set[RBT.rbt[A, Unit], A](rs_empty[A], rs_ins[A])

} /* object RBTSetImpl */

object FiniteListGraph_Impl {

def valid_list_graph_impl_rs[A : Orderings.linorder](v: RBT.rbt[A, Unit],
              x1: List[(A, A)]):
      Boolean =
  (v, x1) match {
  case (v, Nil) => true
  case (v, (v1, v2) :: es) =>
    RBTSetImpl.rs_memb[A].apply(v1).apply(v) &&
      (RBTSetImpl.rs_memb[A].apply(v2).apply(v) &&
        valid_list_graph_impl_rs[A](v, es))
}

def valid_list_graph_impl[A : Orderings.linorder](v: List[A], e: List[(A, A)]):
      Boolean =
  valid_list_graph_impl_rs[A](RBTSetImpl.list_to_rs[A].apply(v), e)

} /* object FiniteListGraph_Impl */

object FiniteListGraph {

import /*implicits*/ Misc.linorder_prod, Product_Type.equal_prod

abstract sealed class list_graph_ext[A, B]
final case class List_graph_ext[A, B](a: List[A], b: List[(A, A)], c: B) extends
  list_graph_ext[A, B]

def edgesL[A, B](x0: list_graph_ext[A, B]): List[(A, A)] = x0 match {
  case List_graph_ext(nodesL, edgesL, more) => edgesL
}

def nodesL[A, B](x0: list_graph_ext[A, B]): List[A] = x0 match {
  case List_graph_ext(nodesL, edgesL, more) => nodesL
}

def edgesL_update[A, B](edgesLa: (List[(A, A)]) => List[(A, A)],
                         x1: list_graph_ext[A, B]):
      list_graph_ext[A, B] =
  (edgesLa, x1) match {
  case (edgesLa, List_graph_ext(nodesL, edgesL, more)) =>
    List_graph_ext[A, B](nodesL, edgesLa(edgesL), more)
}

def add_node[A : HOL.equal](v: A, g: list_graph_ext[A, Unit]):
      list_graph_ext[A, Unit] =
  List_graph_ext[A, Unit]((if (Lista.member[A](nodesL[A, Unit](g), v))
                            nodesL[A, Unit](g) else v :: nodesL[A, Unit](g)),
                           edgesL[A, Unit](g), ())

def add_edge[A : HOL.equal](va: A, v: A, g: list_graph_ext[A, Unit]):
      list_graph_ext[A, Unit] =
  edgesL_update[A, Unit]((_: List[(A, A)]) =>
                           (if (Lista.member[(A,
       A)](edgesL[A, Unit](g), (va, v)))
                             edgesL[A, Unit](g)
                             else (va, v) :: edgesL[A, Unit](g)),
                          add_node[A](va, add_node[A](v, g)))

def backlinks[A](x0: List[(A, A)]): List[(A, A)] = x0 match {
  case Nil => Nil
  case (e1, e2) :: es => (e2, e1) :: backlinks[A](es)
}

def succ_tran[A : HOL.equal](g: list_graph_ext[A, Unit], v: A): List[A] =
  Transitive_Closure_List_Impl.trancl_list_impl[A].apply(edgesL[A,
                         Unit](g)).apply(List(v))

def undirected[A : HOL.equal](g: list_graph_ext[A, Unit]):
      list_graph_ext[A, Unit] =
  List_graph_ext[A, Unit](nodesL[A, Unit](g),
                           Lista.remdups[(A,
   A)](edgesL[A, Unit](g) ++ backlinks[A](edgesL[A, Unit](g))),
                           ())

def delete_edge[A : HOL.equal](va: A, v: A, g: list_graph_ext[A, Unit]):
      list_graph_ext[A, Unit] =
  List_graph_ext[A, Unit](nodesL[A, Unit](g),
                           Lista.filter[(A,
  A)]((a: (A, A)) =>
        {
          val (e1, e2): (A, A) = a;
          ! (HOL.eq[A](e1, va)) || ! (HOL.eq[A](e2, v))
        },
       edgesL[A, Unit](g)),
                           ())

def delete_node[A : HOL.equal](v: A, g: list_graph_ext[A, Unit]):
      list_graph_ext[A, Unit] =
  List_graph_ext[A, Unit](Lista.remove1[A](v, nodesL[A, Unit](g)),
                           Lista.filter[(A,
  A)]((a: (A, A)) =>
        {
          val (e1, e2): (A, A) = a;
          ! (HOL.eq[A](e1, v)) && ! (HOL.eq[A](e2, v))
        },
       edgesL[A, Unit](g)),
                           ())

def delete_edges[A : HOL.equal](g: list_graph_ext[A, Unit], x1: List[(A, A)]):
      list_graph_ext[A, Unit] =
  (g, x1) match {
  case (g, Nil) => g
  case (g, (va, v) :: es) => delete_edges[A](delete_edge[A](va, v, g), es)
}

def num_reachable[A : HOL.equal](g: list_graph_ext[A, Unit], v: A): Nat.nat =
  Lista.size_list[A].apply(succ_tran[A](g, v))

def valid_list_graph_axioms[A : Orderings.linorder](g: list_graph_ext[A, Unit]):
      Boolean =
  FiniteListGraph_Impl.valid_list_graph_impl[A](nodesL[A, Unit](g),
         edgesL[A, Unit](g))

def valid_list_graph[A : HOL.equal : Orderings.linorder](g:
                   list_graph_ext[A, Unit]):
      Boolean =
  Lista.distinct[A](nodesL[A, Unit](g)) &&
    (Lista.distinct[(A, A)](edgesL[A, Unit](g)) &&
      valid_list_graph_axioms[A](g))

} /* object FiniteListGraph */

object NetworkModel_Lists_Impl_Interface {

abstract sealed class networkModel_packed_ext[A, B, C, D]
final case class
  NetworkModel_packed_ext[B, A, C,
                           D](a: List[Char], b: Boolean, c: B,
                               d: (FiniteListGraph.list_graph_ext[A, Unit]) =>
                                    (A => B) => Boolean,
                               e: (FiniteListGraph.list_graph_ext[A, Unit]) =>
                                    (A => B) => C => Boolean,
                               f: (FiniteListGraph.list_graph_ext[A, Unit]) =>
                                    (A => B) => List[List[(A, A)]],
                               g: (NetworkModel_Interface.networkModel_Params_ext[A,
   B, C, Unit]) =>
                                    A => B,
                               h: (FiniteListGraph.list_graph_ext[A, Unit]) =>
                                    (NetworkModel_Interface.networkModel_Params_ext[A,
     B, C, Unit]) =>
                                      Boolean,
                               i: D)
  extends networkModel_packed_ext[A, B, C, D]

def nm_eval[A : NetworkModel_Vertices.vertex, B, C,
             D](x0: networkModel_packed_ext[A, B, C, D]):
      (FiniteListGraph.list_graph_ext[A, Unit]) =>
        (NetworkModel_Interface.networkModel_Params_ext[A, B, C, Unit]) =>
          Boolean =
  x0 match {
  case NetworkModel_packed_ext(nm_name, nm_target_focus, nm_default,
                                nm_eval_model, nm_verify_globals,
                                nm_offending_flows, nm_node_props, nm_eval,
                                more)
    => nm_eval
}

def nm_name[A : NetworkModel_Vertices.vertex, B, C,
             D](x0: networkModel_packed_ext[A, B, C, D]):
      List[Char] =
  x0 match {
  case NetworkModel_packed_ext(nm_name, nm_target_focus, nm_default,
                                nm_eval_model, nm_verify_globals,
                                nm_offending_flows, nm_node_props, nm_eval,
                                more)
    => nm_name
}

def nm_default[A : NetworkModel_Vertices.vertex, B, C,
                D](x0: networkModel_packed_ext[A, B, C, D]):
      B =
  x0 match {
  case NetworkModel_packed_ext(nm_name, nm_target_focus, nm_default,
                                nm_eval_model, nm_verify_globals,
                                nm_offending_flows, nm_node_props, nm_eval,
                                more)
    => nm_default
}

def nm_eval_model[A : NetworkModel_Vertices.vertex, B, C,
                   D](x0: networkModel_packed_ext[A, B, C, D]):
      (FiniteListGraph.list_graph_ext[A, Unit]) => (A => B) => Boolean =
  x0 match {
  case NetworkModel_packed_ext(nm_name, nm_target_focus, nm_default,
                                nm_eval_model, nm_verify_globals,
                                nm_offending_flows, nm_node_props, nm_eval,
                                more)
    => nm_eval_model
}

def nm_node_props[A : NetworkModel_Vertices.vertex, B, C,
                   D](x0: networkModel_packed_ext[A, B, C, D]):
      (NetworkModel_Interface.networkModel_Params_ext[A, B, C, Unit]) =>
        A => B =
  x0 match {
  case NetworkModel_packed_ext(nm_name, nm_target_focus, nm_default,
                                nm_eval_model, nm_verify_globals,
                                nm_offending_flows, nm_node_props, nm_eval,
                                more)
    => nm_node_props
}

def nm_target_focus[A : NetworkModel_Vertices.vertex, B, C,
                     D](x0: networkModel_packed_ext[A, B, C, D]):
      Boolean =
  x0 match {
  case NetworkModel_packed_ext(nm_name, nm_target_focus, nm_default,
                                nm_eval_model, nm_verify_globals,
                                nm_offending_flows, nm_node_props, nm_eval,
                                more)
    => nm_target_focus
}

def nm_verify_globals[A : NetworkModel_Vertices.vertex, B, C,
                       D](x0: networkModel_packed_ext[A, B, C, D]):
      (FiniteListGraph.list_graph_ext[A, Unit]) => (A => B) => C => Boolean =
  x0 match {
  case NetworkModel_packed_ext(nm_name, nm_target_focus, nm_default,
                                nm_eval_model, nm_verify_globals,
                                nm_offending_flows, nm_node_props, nm_eval,
                                more)
    => nm_verify_globals
}

def nm_offending_flows[A : NetworkModel_Vertices.vertex, B, C,
                        D](x0: networkModel_packed_ext[A, B, C, D]):
      (FiniteListGraph.list_graph_ext[A, Unit]) =>
        (A => B) => List[List[(A, A)]] =
  x0 match {
  case NetworkModel_packed_ext(nm_name, nm_target_focus, nm_default,
                                nm_eval_model, nm_verify_globals,
                                nm_offending_flows, nm_node_props, nm_eval,
                                more)
    => nm_offending_flows
}

def generic_offending_list[A : HOL.equal,
                            B](eval_model:
                                 (FiniteListGraph.list_graph_ext[A, Unit]) =>
                                   (A => B) => Boolean,
                                g: FiniteListGraph.list_graph_ext[A, Unit],
                                nP: A => B):
      List[List[(A, A)]] =
  Lista.filter[List[(A, A)]]((f: List[(A, A)]) =>
                               ! ((eval_model(g))(nP)) &&
                                 (eval_model(FiniteListGraph.delete_edges[A](g,
                                      f)))(nP) &&
                                 Lista.list_all[(A,
          A)]((a: (A, A)) =>
                {
                  val (e1, e2): (A, A) = a;
                  ! ((eval_model(FiniteListGraph.add_edge[A](e1, e2,
                      FiniteListGraph.delete_edges[A](g, f))))(nP))
                },
               f),
                              Lista.sublists[(A,
       A)](FiniteListGraph.edgesL[A, Unit](g)))

} /* object NetworkModel_Lists_Impl_Interface */

object NM_Sink {

abstract sealed class node_config
final case class Sink() extends node_config
final case class SinkPool() extends node_config
final case class Unassigned() extends node_config

def target_focus: Boolean = true

def default_node_properties: node_config = Unassigned()

def netModel_node_props[A : NetworkModel_Vertices.vertex, B,
                         C](p: NetworkModel_Interface.networkModel_Params_ext[A,
                                       node_config, B, C]):
      A => node_config =
  (i: A) =>
    ((NetworkModel_Interface.node_properties[A, node_config, B, C](p)).apply(i)
       match {
       case None => default_node_properties
       case Some(property) => property
     })

def verify_globals[A](uu: FiniteListGraph.list_graph_ext[A, Unit],
                       uv: A => node_config, uw: Unit):
      Boolean =
  true

def allowed_sink_flow(x0: node_config, uu: node_config): Boolean = (x0, uu)
  match {
  case (Sink(), uu) => false
  case (SinkPool(), SinkPool()) => true
  case (SinkPool(), Sink()) => true
  case (SinkPool(), Unassigned()) => false
  case (Unassigned(), uw) => true
}

def eval_model[A : HOL.equal](g: FiniteListGraph.list_graph_ext[A, Unit],
                               nP: A => node_config):
      Boolean =
  Lista.list_all[(A, A)]((a: (A, A)) =>
                           {
                             val (e1, e2): (A, A) = a;
                             (if (! (HOL.eq[A](e1, e2)))
                               allowed_sink_flow(nP(e1), nP(e2)) else true)
                           },
                          FiniteListGraph.edgesL[A, Unit](g))

def sink_eval[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder](g:
   FiniteListGraph.list_graph_ext[A, Unit],
  p: NetworkModel_Interface.networkModel_Params_ext[A, node_config, Unit,
             Unit]):
      Boolean =
  FiniteListGraph.valid_list_graph[A](g) &&
    (verify_globals[A](g, netModel_node_props[A, Unit, Unit](p),
                        NetworkModel_Interface.model_global_properties[A,
                                node_config, Unit, Unit](p)) &&
      eval_model[A](g, netModel_node_props[A, Unit, Unit](p)))

def sink_offending_list[A : HOL.equal](g:
 FiniteListGraph.list_graph_ext[A, Unit],
nP: A => node_config):
      List[List[(A, A)]] =
  (if (eval_model[A](g, nP)) Nil
    else List(Lista.filter[(A, A)]((a: (A, A)) =>
                                     {
                                       val (e1, e2): (A, A) = a;
                                       ! (HOL.eq[A](e1, e2)) &&
 ! (allowed_sink_flow(nP(e1), nP(e2)))
                                     },
                                    FiniteListGraph.edgesL[A, Unit](g))))

def nM_LIB_Sink[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder]:
      NetworkModel_Lists_Impl_Interface.networkModel_packed_ext[A, node_config,
                         Unit, Unit] =
  NetworkModel_Lists_Impl_Interface.NetworkModel_packed_ext[node_config, A,
                     Unit,
                     Unit](List('S', 'i', 'n', 'k'), target_focus,
                            default_node_properties,
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => node_config) => eval_model[A](a, b),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => node_config) =>
                                (c: Unit) => verify_globals[A](a, b, c),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => node_config) =>
                                sink_offending_list[A](a, b),
                            (a: NetworkModel_Interface.networkModel_Params_ext[A,
node_config, Unit, Unit])
                              => netModel_node_props[A, Unit, Unit](a),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: NetworkModel_Interface.networkModel_Params_ext[A,
  node_config, Unit, Unit])
                                => sink_eval[A](a, b),
                            ())

} /* object NM_Sink */

object NM_Subnets {

abstract sealed class subnets
final case class Subnet(a: Nat.nat) extends subnets
final case class BorderRouter(a: Nat.nat) extends subnets
final case class Unassigned() extends subnets

def target_focus: Boolean = false

def allowed_subnet_flow(x0: subnets, x1: subnets): Boolean = (x0, x1) match {
  case (Subnet(s1), Subnet(s2)) => Nat.equal_nat(s1, s2)
  case (Subnet(s1), BorderRouter(s2)) => Nat.equal_nat(s1, s2)
  case (Subnet(s1), Unassigned()) => true
  case (BorderRouter(s1), Subnet(s2)) => false
  case (BorderRouter(s1), Unassigned()) => true
  case (BorderRouter(s1), BorderRouter(s2)) => true
  case (Unassigned(), Unassigned()) => true
  case (Unassigned(), Subnet(v)) => false
  case (Unassigned(), BorderRouter(v)) => false
}

def eval_model[A](g: FiniteListGraph.list_graph_ext[A, Unit], nP: A => subnets):
      Boolean =
  Lista.list_all[(A, A)]((a: (A, A)) =>
                           {
                             val (e1, e2): (A, A) = a;
                             allowed_subnet_flow(nP(e1), nP(e2))
                           },
                          FiniteListGraph.edgesL[A, Unit](g))

def default_node_properties: subnets = Unassigned()

def netModel_node_props[A : NetworkModel_Vertices.vertex, B,
                         C](p: NetworkModel_Interface.networkModel_Params_ext[A,
                                       subnets, B, C]):
      A => subnets =
  (i: A) =>
    ((NetworkModel_Interface.node_properties[A, subnets, B, C](p)).apply(i)
       match {
       case None => default_node_properties
       case Some(property) => property
     })

def verify_globals[A](uu: FiniteListGraph.list_graph_ext[A, Unit],
                       uv: A => subnets, uw: Unit):
      Boolean =
  true

def subnets_eval[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder](g:
      FiniteListGraph.list_graph_ext[A, Unit],
     p: NetworkModel_Interface.networkModel_Params_ext[A, subnets, Unit, Unit]):
      Boolean =
  FiniteListGraph.valid_list_graph[A](g) &&
    (verify_globals[A](g, netModel_node_props[A, Unit, Unit](p),
                        NetworkModel_Interface.model_global_properties[A,
                                subnets, Unit, Unit](p)) &&
      eval_model[A](g, netModel_node_props[A, Unit, Unit](p)))

def subnets_offending_list[A](g: FiniteListGraph.list_graph_ext[A, Unit],
                               nP: A => subnets):
      List[List[(A, A)]] =
  (if (eval_model[A](g, nP)) Nil
    else List(Lista.filter[(A, A)]((a: (A, A)) =>
                                     {
                                       val (e1, e2): (A, A) = a;
                                       ! (allowed_subnet_flow(nP(e1), nP(e2)))
                                     },
                                    FiniteListGraph.edgesL[A, Unit](g))))

def nM_LIB_Subnets[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder]:
      NetworkModel_Lists_Impl_Interface.networkModel_packed_ext[A, subnets,
                         Unit, Unit] =
  NetworkModel_Lists_Impl_Interface.NetworkModel_packed_ext[subnets, A, Unit,
                     Unit](List('S', 'u', 'b', 'n', 'e', 't', 's'),
                            target_focus, default_node_properties,
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => subnets) => eval_model[A](a, b),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => subnets) =>
                                (c: Unit) => verify_globals[A](a, b, c),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => subnets) =>
                                subnets_offending_list[A](a, b),
                            (a: NetworkModel_Interface.networkModel_Params_ext[A,
subnets, Unit, Unit])
                              => netModel_node_props[A, Unit, Unit](a),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: NetworkModel_Interface.networkModel_Params_ext[A,
  subnets, Unit, Unit])
                                => subnets_eval[A](a, b),
                            ())

} /* object NM_Subnets */

object NM_BLPbasic {

import /*implicits*/ NetworkModel_Vertices.equal_vString

def fabNet:
      FiniteListGraph.list_graph_ext[NetworkModel_Vertices.vString, Unit] =
  FiniteListGraph.List_graph_ext[NetworkModel_Vertices.vString,
                                  Unit](List(NetworkModel_Vertices.V(List('S',
                                   't', 'a', 't', 'i', 's', 't', 'i', 'c',
                                   's')),
      NetworkModel_Vertices.V(List('S', 'e', 'n', 's', 'o', 'r', 'S', 'i', 'n',
                                    'k')),
      NetworkModel_Vertices.V(List('P', 'r', 'e', 's', 'e', 'n', 'c', 'e', 'S',
                                    'e', 'n', 's', 'o', 'r')),
      NetworkModel_Vertices.V(List('W', 'e', 'b', 'c', 'a', 'm')),
      NetworkModel_Vertices.V(List('T', 'e', 'm', 'p', 'S', 'e', 'n', 's', 'o',
                                    'r')),
      NetworkModel_Vertices.V(List('F', 'i', 'r', 'e', 'S', 'e', 's', 'n', 's',
                                    'o', 'r')),
      NetworkModel_Vertices.V(List('M', 'i', 's', 's', 'i', 'o', 'n', 'C', 'o',
                                    'n', 't', 'r', 'o', 'l', '1')),
      NetworkModel_Vertices.V(List('M', 'i', 's', 's', 'i', 'o', 'n', 'C', 'o',
                                    'n', 't', 'r', 'o', 'l', '2')),
      NetworkModel_Vertices.V(List('W', 'a', 't', 'c', 'h', 'd', 'o', 'g')),
      NetworkModel_Vertices.V(List('B', 'o', 't', '1')),
      NetworkModel_Vertices.V(List('B', 'o', 't', '2'))),
 List((NetworkModel_Vertices.V(List('P', 'r', 'e', 's', 'e', 'n', 'c', 'e', 'S',
                                     'e', 'n', 's', 'o', 'r')),
        NetworkModel_Vertices.V(List('S', 'e', 'n', 's', 'o', 'r', 'S', 'i',
                                      'n', 'k'))),
       (NetworkModel_Vertices.V(List('W', 'e', 'b', 'c', 'a', 'm')),
         NetworkModel_Vertices.V(List('S', 'e', 'n', 's', 'o', 'r', 'S', 'i',
                                       'n', 'k'))),
       (NetworkModel_Vertices.V(List('T', 'e', 'm', 'p', 'S', 'e', 'n', 's',
                                      'o', 'r')),
         NetworkModel_Vertices.V(List('S', 'e', 'n', 's', 'o', 'r', 'S', 'i',
                                       'n', 'k'))),
       (NetworkModel_Vertices.V(List('F', 'i', 'r', 'e', 'S', 'e', 's', 'n',
                                      's', 'o', 'r')),
         NetworkModel_Vertices.V(List('S', 'e', 'n', 's', 'o', 'r', 'S', 'i',
                                       'n', 'k'))),
       (NetworkModel_Vertices.V(List('S', 'e', 'n', 's', 'o', 'r', 'S', 'i',
                                      'n', 'k')),
         NetworkModel_Vertices.V(List('S', 't', 'a', 't', 'i', 's', 't', 'i',
                                       'c', 's'))),
       (NetworkModel_Vertices.V(List('M', 'i', 's', 's', 'i', 'o', 'n', 'C',
                                      'o', 'n', 't', 'r', 'o', 'l', '1')),
         NetworkModel_Vertices.V(List('B', 'o', 't', '1'))),
       (NetworkModel_Vertices.V(List('M', 'i', 's', 's', 'i', 'o', 'n', 'C',
                                      'o', 'n', 't', 'r', 'o', 'l', '1')),
         NetworkModel_Vertices.V(List('B', 'o', 't', '2'))),
       (NetworkModel_Vertices.V(List('M', 'i', 's', 's', 'i', 'o', 'n', 'C',
                                      'o', 'n', 't', 'r', 'o', 'l', '2')),
         NetworkModel_Vertices.V(List('B', 'o', 't', '2'))),
       (NetworkModel_Vertices.V(List('W', 'a', 't', 'c', 'h', 'd', 'o', 'g')),
         NetworkModel_Vertices.V(List('B', 'o', 't', '1'))),
       (NetworkModel_Vertices.V(List('W', 'a', 't', 'c', 'h', 'd', 'o', 'g')),
         NetworkModel_Vertices.V(List('B', 'o', 't', '2')))),
 ())

def target_focus: Boolean = true

def default_node_properties: Nat.nat = Nat.zero_nat

def netModel_node_props[A : NetworkModel_Vertices.vertex, B,
                         C](p: NetworkModel_Interface.networkModel_Params_ext[A,
                                       Nat.nat, B, C]):
      A => Nat.nat =
  (i: A) =>
    ((NetworkModel_Interface.node_properties[A, Nat.nat, B, C](p)).apply(i)
       match {
       case None => default_node_properties
       case Some(property) => property
     })

def verify_globals[A](uu: FiniteListGraph.list_graph_ext[A, Unit],
                       uv: A => Nat.nat, uw: Unit):
      Boolean =
  true

def eval_model[A](g: FiniteListGraph.list_graph_ext[A, Unit], nP: A => Nat.nat):
      Boolean =
  Lista.list_all[(A, A)]((a: (A, A)) =>
                           {
                             val (e1, e2): (A, A) = a;
                             Nat.less_eq_nat(nP(e1), nP(e2))
                           },
                          FiniteListGraph.edgesL[A, Unit](g))

def bLP_eval[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder](g:
  FiniteListGraph.list_graph_ext[A, Unit],
 p: NetworkModel_Interface.networkModel_Params_ext[A, Nat.nat, Unit, Unit]):
      Boolean =
  FiniteListGraph.valid_list_graph[A](g) &&
    (verify_globals[A](g, netModel_node_props[A, Unit, Unit](p),
                        NetworkModel_Interface.model_global_properties[A,
                                Nat.nat, Unit, Unit](p)) &&
      eval_model[A](g, netModel_node_props[A, Unit, Unit](p)))

def bLP_offending_list[A](g: FiniteListGraph.list_graph_ext[A, Unit],
                           nP: A => Nat.nat):
      List[List[(A, A)]] =
  (if (eval_model[A](g, nP)) Nil
    else List(Lista.filter[(A, A)]((a: (A, A)) =>
                                     {
                                       val (e1, e2): (A, A) = a;
                                       Nat.less_nat(nP(e2), nP(e1))
                                     },
                                    FiniteListGraph.edgesL[A, Unit](g))))

def nM_LIB_BLPbasic[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder]:
      NetworkModel_Lists_Impl_Interface.networkModel_packed_ext[A, Nat.nat,
                         Unit, Unit] =
  NetworkModel_Lists_Impl_Interface.NetworkModel_packed_ext[Nat.nat, A, Unit,
                     Unit](List('B', 'L', 'P', 'b', 'a', 's', 'i', 'c'),
                            target_focus, default_node_properties,
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => Nat.nat) => eval_model[A](a, b),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => Nat.nat) =>
                                (c: Unit) => verify_globals[A](a, b, c),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => Nat.nat) => bLP_offending_list[A](a, b),
                            (a: NetworkModel_Interface.networkModel_Params_ext[A,
Nat.nat, Unit, Unit])
                              => netModel_node_props[A, Unit, Unit](a),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: NetworkModel_Interface.networkModel_Params_ext[A,
  Nat.nat, Unit, Unit])
                                => bLP_eval[A](a, b),
                            ())

def sensorProps_NMParams_try3:
      NetworkModel_Interface.networkModel_Params_ext[NetworkModel_Vertices.vString,
              Nat.nat, Unit, Unit] =
  NetworkModel_Interface.NetworkModel_Params_ext[NetworkModel_Vertices.vString,
          Nat.nat, Unit,
          Unit](Fun.fun_upd[NetworkModel_Vertices.vString,
                             Option[Nat.nat]](Fun.fun_upd[NetworkModel_Vertices.vString,
                   Option[Nat.nat]](Fun.fun_upd[NetworkModel_Vertices.vString,
         Option[Nat.nat]](Fun.fun_upd[NetworkModel_Vertices.vString,
                                       Option[Nat.nat]]((_:
                   NetworkModel_Vertices.vString)
                  => None,
                 NetworkModel_Vertices.V(List('P', 'r', 'e', 's', 'e', 'n', 'c',
       'e', 'S', 'e', 'n', 's', 'o', 'r')),
                 Some[Nat.nat](Code_Numeral.nat_of_integer(BigInt(2)))),
                           NetworkModel_Vertices.V(List('W', 'e', 'b', 'c', 'a',
                 'm')),
                           Some[Nat.nat](Code_Numeral.nat_of_integer(BigInt(3)))),
                                     NetworkModel_Vertices.V(List('S', 'e', 'n',
                           's', 'o', 'r', 'S', 'i', 'n', 'k')),
                                     Some[Nat.nat](Code_Numeral.nat_of_integer(BigInt(3)))),
       NetworkModel_Vertices.V(List('S', 't', 'a', 't', 'i', 's', 't', 'i', 'c',
                                     's')),
       Some[Nat.nat](Code_Numeral.nat_of_integer(BigInt(3)))),
                 (), ())

} /* object NM_BLPbasic */

object NM_SecGwExt {

abstract sealed class secgw_member
final case class SecurityGateway() extends secgw_member
final case class SecurityGatewayIN() extends secgw_member
final case class DomainMember() extends secgw_member
final case class AccessibleMember() extends secgw_member
final case class Unassigned() extends secgw_member

def target_focus: Boolean = false

def allowed_secgw_flow(x0: secgw_member, uu: secgw_member): Boolean = (x0, uu)
  match {
  case (SecurityGateway(), uu) => true
  case (SecurityGatewayIN(), uv) => true
  case (DomainMember(), DomainMember()) => false
  case (DomainMember(), SecurityGateway()) => true
  case (DomainMember(), SecurityGatewayIN()) => true
  case (DomainMember(), AccessibleMember()) => true
  case (DomainMember(), Unassigned()) => true
  case (AccessibleMember(), DomainMember()) => false
  case (AccessibleMember(), SecurityGateway()) => true
  case (AccessibleMember(), SecurityGatewayIN()) => true
  case (AccessibleMember(), AccessibleMember()) => true
  case (AccessibleMember(), Unassigned()) => true
  case (Unassigned(), Unassigned()) => true
  case (Unassigned(), SecurityGatewayIN()) => true
  case (Unassigned(), AccessibleMember()) => true
  case (Unassigned(), SecurityGateway()) => false
  case (Unassigned(), DomainMember()) => false
}

def eval_model[A : HOL.equal](g: FiniteListGraph.list_graph_ext[A, Unit],
                               nP: A => secgw_member):
      Boolean =
  Lista.list_all[(A, A)]((a: (A, A)) =>
                           {
                             val (e1, e2): (A, A) = a;
                             (if (! (HOL.eq[A](e1, e2)))
                               allowed_secgw_flow(nP(e1), nP(e2)) else true)
                           },
                          FiniteListGraph.edgesL[A, Unit](g))

def verify_globals[A](uu: FiniteListGraph.list_graph_ext[A, Unit],
                       uv: A => secgw_member, uw: Unit):
      Boolean =
  true

def default_node_properties: secgw_member = Unassigned()

def netModel_node_props[A : NetworkModel_Vertices.vertex, B,
                         C](p: NetworkModel_Interface.networkModel_Params_ext[A,
                                       secgw_member, B, C]):
      A => secgw_member =
  (i: A) =>
    ((NetworkModel_Interface.node_properties[A, secgw_member, B, C](p)).apply(i)
       match {
       case None => default_node_properties
       case Some(property) => property
     })

def securityGateway_eval[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder](g:
              FiniteListGraph.list_graph_ext[A, Unit],
             p: NetworkModel_Interface.networkModel_Params_ext[A, secgw_member,
                        Unit, Unit]):
      Boolean =
  FiniteListGraph.valid_list_graph[A](g) &&
    (verify_globals[A](g, netModel_node_props[A, Unit, Unit](p),
                        NetworkModel_Interface.model_global_properties[A,
                                secgw_member, Unit, Unit](p)) &&
      eval_model[A](g, netModel_node_props[A, Unit, Unit](p)))

def securityGateway_offending_list[A : HOL.equal](g:
            FiniteListGraph.list_graph_ext[A, Unit],
           nP: A => secgw_member):
      List[List[(A, A)]] =
  (if (eval_model[A](g, nP)) Nil
    else List(Lista.filter[(A, A)]((a: (A, A)) =>
                                     {
                                       val (e1, e2): (A, A) = a;
                                       ! (HOL.eq[A](e1, e2)) &&
 ! (allowed_secgw_flow(nP(e1), nP(e2)))
                                     },
                                    FiniteListGraph.edgesL[A, Unit](g))))

def nM_LIB_SecurityGatewayExtended[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder]:
      NetworkModel_Lists_Impl_Interface.networkModel_packed_ext[A, secgw_member,
                         Unit, Unit] =
  NetworkModel_Lists_Impl_Interface.NetworkModel_packed_ext[secgw_member, A,
                     Unit,
                     Unit](List('S', 'e', 'c', 'u', 'r', 'i', 't', 'y', 'G',
                                 'a', 't', 'e', 'w', 'a', 'y', 'E', 'x', 't',
                                 'e', 'n', 'd', 'e', 'd'),
                            target_focus, default_node_properties,
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => secgw_member) => eval_model[A](a, b),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => secgw_member) =>
                                (c: Unit) => verify_globals[A](a, b, c),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => secgw_member) =>
                                securityGateway_offending_list[A](a, b),
                            (a: NetworkModel_Interface.networkModel_Params_ext[A,
secgw_member, Unit, Unit])
                              => netModel_node_props[A, Unit, Unit](a),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: NetworkModel_Interface.networkModel_Params_ext[A,
  secgw_member, Unit, Unit])
                                => securityGateway_eval[A](a, b),
                            ())

} /* object NM_SecGwExt */

object NM_BLPtrusted {

abstract sealed class node_config_ext[A]
final case class Node_config_ext[A](a: Nat.nat, b: Boolean, c: A) extends
  node_config_ext[A]

def privacy_level[A](x0: node_config_ext[A]): Nat.nat = x0 match {
  case Node_config_ext(privacy_level, trusted, more) => privacy_level
}

def trusted[A](x0: node_config_ext[A]): Boolean = x0 match {
  case Node_config_ext(privacy_level, trusted, more) => trusted
}

def bLP_P[A, B]: (node_config_ext[A]) => (node_config_ext[B]) => Boolean =
  (n1: node_config_ext[A]) =>
    (n2: node_config_ext[B]) =>
      (if (trusted[B](n2)) true
        else Nat.less_eq_nat(privacy_level[A](n1), privacy_level[B](n2)))

def target_focus: Boolean = true

def default_node_properties: node_config_ext[Unit] =
  Node_config_ext[Unit](Nat.zero_nat, false, ())

def netModel_node_props[A : NetworkModel_Vertices.vertex, B,
                         C](p: NetworkModel_Interface.networkModel_Params_ext[A,
                                       node_config_ext[Unit], B, C]):
      A => node_config_ext[Unit] =
  (i: A) =>
    ((NetworkModel_Interface.node_properties[A, node_config_ext[Unit], B,
      C](p)).apply(i)
       match {
       case None => default_node_properties
       case Some(property) => property
     })

def verify_globals[A](uu: FiniteListGraph.list_graph_ext[A, Unit],
                       uv: A => node_config_ext[Unit], uw: Unit):
      Boolean =
  true

def eval_model[A](g: FiniteListGraph.list_graph_ext[A, Unit],
                   nP: A => node_config_ext[Unit]):
      Boolean =
  Lista.list_all[(A, A)]((a: (A, A)) =>
                           {
                             val (e1, e2): (A, A) = a;
                             (if (trusted[Unit](nP(e2))) true
                               else Nat.less_eq_nat(privacy_level[Unit](nP(e1)),
             privacy_level[Unit](nP(e2))))
                           },
                          FiniteListGraph.edgesL[A, Unit](g))

def bLP_eval[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder](g:
  FiniteListGraph.list_graph_ext[A, Unit],
 p: NetworkModel_Interface.networkModel_Params_ext[A, node_config_ext[Unit],
            Unit, Unit]):
      Boolean =
  FiniteListGraph.valid_list_graph[A](g) &&
    (verify_globals[A](g, netModel_node_props[A, Unit, Unit](p),
                        NetworkModel_Interface.model_global_properties[A,
                                node_config_ext[Unit], Unit, Unit](p)) &&
      eval_model[A](g, netModel_node_props[A, Unit, Unit](p)))

def bLP_offending_list[A](g: FiniteListGraph.list_graph_ext[A, Unit],
                           nP: A => node_config_ext[Unit]):
      List[List[(A, A)]] =
  (if (eval_model[A](g, nP)) Nil
    else List(Lista.filter[(A, A)]((a: (A, A)) =>
                                     {
                                       val (e1, e2): (A, A) = a;
                                       ! bLP_P[Unit,
        Unit].apply(nP(e1)).apply(nP(e2))
                                     },
                                    FiniteListGraph.edgesL[A, Unit](g))))

def nM_LIB_BLPtrusted[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder]:
      NetworkModel_Lists_Impl_Interface.networkModel_packed_ext[A,
                         node_config_ext[Unit], Unit, Unit] =
  NetworkModel_Lists_Impl_Interface.NetworkModel_packed_ext[node_config_ext[Unit],
                     A, Unit,
                     Unit](List('B', 'L', 'P', 't', 'r', 'u', 's', 't', 'e',
                                 'd'),
                            target_focus, default_node_properties,
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => node_config_ext[Unit]) =>
                                eval_model[A](a, b),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => node_config_ext[Unit]) =>
                                (c: Unit) => verify_globals[A](a, b, c),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => node_config_ext[Unit]) =>
                                bLP_offending_list[A](a, b),
                            (a: NetworkModel_Interface.networkModel_Params_ext[A,
node_config_ext[Unit], Unit, Unit])
                              => netModel_node_props[A, Unit, Unit](a),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: NetworkModel_Interface.networkModel_Params_ext[A,
  node_config_ext[Unit], Unit, Unit])
                                => bLP_eval[A](a, b),
                            ())

} /* object NM_BLPtrusted */

object NM_SubnetsInGW {

abstract sealed class subnets
final case class Member() extends subnets
final case class InboundGateway() extends subnets
final case class Unassigned() extends subnets

def target_focus: Boolean = false

def allowed_subnet_flow(x0: subnets, uu: subnets): Boolean = (x0, uu) match {
  case (Member(), uu) => true
  case (InboundGateway(), uv) => true
  case (Unassigned(), Unassigned()) => true
  case (Unassigned(), InboundGateway()) => true
  case (Unassigned(), Member()) => false
}

def eval_model[A](g: FiniteListGraph.list_graph_ext[A, Unit], nP: A => subnets):
      Boolean =
  Lista.list_all[(A, A)]((a: (A, A)) =>
                           {
                             val (e1, e2): (A, A) = a;
                             allowed_subnet_flow(nP(e1), nP(e2))
                           },
                          FiniteListGraph.edgesL[A, Unit](g))

def verify_globals[A](uu: FiniteListGraph.list_graph_ext[A, Unit],
                       uv: A => subnets, uw: Unit):
      Boolean =
  true

def default_node_properties: subnets = Unassigned()

def netModel_node_props[A : NetworkModel_Vertices.vertex, B,
                         C](p: NetworkModel_Interface.networkModel_Params_ext[A,
                                       subnets, B, C]):
      A => subnets =
  (i: A) =>
    ((NetworkModel_Interface.node_properties[A, subnets, B, C](p)).apply(i)
       match {
       case None => default_node_properties
       case Some(property) => property
     })

def subnetsInGW_eval[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder](g:
          FiniteListGraph.list_graph_ext[A, Unit],
         p: NetworkModel_Interface.networkModel_Params_ext[A, subnets, Unit,
                    Unit]):
      Boolean =
  FiniteListGraph.valid_list_graph[A](g) &&
    (verify_globals[A](g, netModel_node_props[A, Unit, Unit](p),
                        NetworkModel_Interface.model_global_properties[A,
                                subnets, Unit, Unit](p)) &&
      eval_model[A](g, netModel_node_props[A, Unit, Unit](p)))

def subnetsInGW_offending_list[A](g: FiniteListGraph.list_graph_ext[A, Unit],
                                   nP: A => subnets):
      List[List[(A, A)]] =
  (if (eval_model[A](g, nP)) Nil
    else List(Lista.filter[(A, A)]((a: (A, A)) =>
                                     {
                                       val (e1, e2): (A, A) = a;
                                       ! (allowed_subnet_flow(nP(e1), nP(e2)))
                                     },
                                    FiniteListGraph.edgesL[A, Unit](g))))

def nM_LIB_SubnetsInGW[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder]:
      NetworkModel_Lists_Impl_Interface.networkModel_packed_ext[A, subnets,
                         Unit, Unit] =
  NetworkModel_Lists_Impl_Interface.NetworkModel_packed_ext[subnets, A, Unit,
                     Unit](List('S', 'u', 'b', 'n', 'e', 't', 's', 'I', 'n',
                                 'G', 'W'),
                            target_focus, default_node_properties,
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => subnets) => eval_model[A](a, b),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => subnets) =>
                                (c: Unit) => verify_globals[A](a, b, c),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => subnets) =>
                                subnetsInGW_offending_list[A](a, b),
                            (a: NetworkModel_Interface.networkModel_Params_ext[A,
subnets, Unit, Unit])
                              => netModel_node_props[A, Unit, Unit](a),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: NetworkModel_Interface.networkModel_Params_ext[A,
  subnets, Unit, Unit])
                                => subnetsInGW_eval[A](a, b),
                            ())

} /* object NM_SubnetsInGW */

object NM_Dependability {

def target_focus: Boolean = false

def eval_model[A : HOL.equal](g: FiniteListGraph.list_graph_ext[A, Unit],
                               nP: A => Nat.nat):
      Boolean =
  Lista.list_all[(A, A)]((a: (A, A)) =>
                           {
                             val (e1, _): (A, A) = a;
                             Nat.less_eq_nat(FiniteListGraph.num_reachable[A](g,
                                       e1),
      nP(e1))
                           },
                          FiniteListGraph.edgesL[A, Unit](g))

def verify_globals[A](uu: FiniteListGraph.list_graph_ext[A, Unit],
                       uv: A => Nat.nat, uw: Unit):
      Boolean =
  true

def default_node_properties: Nat.nat = Nat.zero_nat

def netModel_node_props[A : NetworkModel_Vertices.vertex, B,
                         C](p: NetworkModel_Interface.networkModel_Params_ext[A,
                                       Nat.nat, B, C]):
      A => Nat.nat =
  (i: A) =>
    ((NetworkModel_Interface.node_properties[A, Nat.nat, B, C](p)).apply(i)
       match {
       case None => default_node_properties
       case Some(property) => property
     })

def dependability_eval[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder](g:
            FiniteListGraph.list_graph_ext[A, Unit],
           p: NetworkModel_Interface.networkModel_Params_ext[A, Nat.nat, Unit,
                      Unit]):
      Boolean =
  FiniteListGraph.valid_list_graph[A](g) &&
    (verify_globals[A](g, netModel_node_props[A, Unit, Unit](p),
                        NetworkModel_Interface.model_global_properties[A,
                                Nat.nat, Unit, Unit](p)) &&
      eval_model[A](g, netModel_node_props[A, Unit, Unit](p)))

def dependability_offending_list[A : HOL.equal]:
      (FiniteListGraph.list_graph_ext[A, Unit]) =>
        (A => Nat.nat) => List[List[(A, A)]] =
  (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
    (b: A => Nat.nat) =>
      NetworkModel_Lists_Impl_Interface.generic_offending_list[A,
                        Nat.nat]((aa: FiniteListGraph.list_graph_ext[A, Unit])
                                   => (ba: A => Nat.nat) =>
eval_model[A](aa, ba),
                                  a, b)

def nM_LIB_Dependability[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder]:
      NetworkModel_Lists_Impl_Interface.networkModel_packed_ext[A, Nat.nat,
                         Unit, Unit] =
  NetworkModel_Lists_Impl_Interface.NetworkModel_packed_ext[Nat.nat, A, Unit,
                     Unit](List('D', 'e', 'p', 'e', 'n', 'd', 'a', 'b', 'i',
                                 'l', 'i', 't', 'y'),
                            target_focus, default_node_properties,
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => Nat.nat) => eval_model[A](a, b),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => Nat.nat) =>
                                (c: Unit) => verify_globals[A](a, b, c),
                            dependability_offending_list[A],
                            (a: NetworkModel_Interface.networkModel_Params_ext[A,
Nat.nat, Unit, Unit])
                              => netModel_node_props[A, Unit, Unit](a),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: NetworkModel_Interface.networkModel_Params_ext[A,
  Nat.nat, Unit, Unit])
                                => dependability_eval[A](a, b),
                            ())

} /* object NM_Dependability */

object datatype_DomainHierarchy {

import /*implicits*/ String.equal_char

abstract sealed class domainName
final case class Dept(a: List[Char], b: domainName) extends domainName
final case class Leaf() extends domainName
final case class Unassigned() extends domainName

abstract sealed class domainTree
final case class Department(a: List[Char], b: List[domainTree]) extends
  domainTree

def hierarchy_next(x0: List[domainTree], uu: domainName): Option[domainTree] =
  (x0, uu) match {
  case (Nil, uu) => None
  case (s :: ss, Unassigned()) => None
  case (s :: ss, Leaf()) => None
  case (Department(d, ds) :: ss, Dept(n, ns)) =>
    (if (Lista.equal_list[Char](d, n)) Some[domainTree](Department(d, ds))
      else hierarchy_next(ss, Dept(n, ns)))
}

def equal_domainName(x0: domainName, x1: domainName): Boolean = (x0, x1) match {
  case (Unassigned(), Leaf()) => false
  case (Leaf(), Unassigned()) => false
  case (Unassigned(), Dept(list, domainName)) => false
  case (Dept(list, domainName), Unassigned()) => false
  case (Leaf(), Dept(list, domainName)) => false
  case (Dept(list, domainName), Leaf()) => false
  case (Dept(lista, domainNamea), Dept(list, domainName)) =>
    Lista.equal_list[Char](lista, list) &&
      equal_domainName(domainNamea, domainName)
  case (Unassigned(), Unassigned()) => true
  case (Leaf(), Leaf()) => true
}

def less_eq_domainName(x0: domainName, x1: domainName): Boolean = (x0, x1) match
  {
  case (Unassigned(), Unassigned()) => true
  case (Unassigned(), Leaf()) => true
  case (Leaf(), Unassigned()) => false
  case (Unassigned(), Dept(uu, uv)) => true
  case (Dept(uw, ux), Unassigned()) => false
  case (Leaf(), Dept(uy, uz)) => false
  case (Dept(va, vb), Leaf()) => true
  case (Leaf(), Leaf()) => true
  case (Dept(n1, n1s), Dept(n2, n2s)) =>
    Lista.equal_list[Char](n1, n2) && less_eq_domainName(n1s, n2s)
}

def valid_hierarchy_pos(x0: domainTree, x1: domainName): Boolean = (x0, x1)
  match {
  case (Department(d, ds), Unassigned()) => true
  case (Department(d, ds), Leaf()) => false
  case (Department(d, ds), Dept(n, Leaf())) => Lista.equal_list[Char](d, n)
  case (Department(d, ds), Dept(n, Dept(v, va))) =>
    Lista.equal_list[Char](n, d) &&
      (hierarchy_next(ds, Dept(v, va)) match {
         case None => false
         case Some(t) => valid_hierarchy_pos(t, Dept(v, va))
       })
  case (Department(d, ds), Dept(n, Unassigned())) =>
    Lista.equal_list[Char](n, d) &&
      (hierarchy_next(ds, Unassigned()) match {
         case None => false
         case Some(t) => valid_hierarchy_pos(t, Unassigned())
       })
}

} /* object datatype_DomainHierarchy */

object NM_DomainHierarchy {

def target_focus: Boolean = false

def eval_model[A](g: FiniteListGraph.list_graph_ext[A, Unit],
                   nP: A => datatype_DomainHierarchy.domainName):
      Boolean =
  Lista.list_all[(A, A)]((a: (A, A)) =>
                           {
                             val (e1, e2): (A, A) = a;
                             datatype_DomainHierarchy.less_eq_domainName(nP(e2),
                                  nP(e1))
                           },
                          FiniteListGraph.edgesL[A, Unit](g))

def verify_globals[A](g: FiniteListGraph.list_graph_ext[A, Unit],
                       nP: A => datatype_DomainHierarchy.domainName,
                       tree: datatype_DomainHierarchy.domainTree):
      Boolean =
  Lista.list_all[A]((v: A) =>
                      datatype_DomainHierarchy.valid_hierarchy_pos(tree, nP(v)),
                     FiniteListGraph.nodesL[A, Unit](g))

def default_node_properties: datatype_DomainHierarchy.domainName =
  datatype_DomainHierarchy.Unassigned()

def netModel_node_props[A : NetworkModel_Vertices.vertex, B,
                         C](p: NetworkModel_Interface.networkModel_Params_ext[A,
                                       datatype_DomainHierarchy.domainName, B,
                                       C]):
      A => datatype_DomainHierarchy.domainName =
  (i: A) =>
    ((NetworkModel_Interface.node_properties[A,
      datatype_DomainHierarchy.domainName, B, C](p)).apply(i)
       match {
       case None => default_node_properties
       case Some(property) => property
     })

def domainHierarchy_eval[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder](g:
              FiniteListGraph.list_graph_ext[A, Unit],
             p: NetworkModel_Interface.networkModel_Params_ext[A,
                        datatype_DomainHierarchy.domainName,
                        datatype_DomainHierarchy.domainTree, Unit]):
      Boolean =
  FiniteListGraph.valid_list_graph[A](g) &&
    (verify_globals[A](g, netModel_node_props[A,
       datatype_DomainHierarchy.domainTree, Unit](p),
                        NetworkModel_Interface.model_global_properties[A,
                                datatype_DomainHierarchy.domainName,
                                datatype_DomainHierarchy.domainTree,
                                Unit](p)) &&
      eval_model[A](g, netModel_node_props[A,
    datatype_DomainHierarchy.domainTree, Unit](p)))

def domainHierarchy_offending_list[A](g:
FiniteListGraph.list_graph_ext[A, Unit],
                                       nP:
 A => datatype_DomainHierarchy.domainName):
      List[List[(A, A)]] =
  (if (eval_model[A](g, nP)) Nil
    else List(Lista.filter[(A, A)]((a: (A, A)) =>
                                     {
                                       val (e1, e2): (A, A) = a;
                                       ! (datatype_DomainHierarchy.less_eq_domainName(nP(e2),
       nP(e1)))
                                     },
                                    FiniteListGraph.edgesL[A, Unit](g))))

def nM_LIB_DomainHierarchy[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder]:
      NetworkModel_Lists_Impl_Interface.networkModel_packed_ext[A,
                         datatype_DomainHierarchy.domainName,
                         datatype_DomainHierarchy.domainTree, Unit] =
  NetworkModel_Lists_Impl_Interface.NetworkModel_packed_ext[datatype_DomainHierarchy.domainName,
                     A, datatype_DomainHierarchy.domainTree,
                     Unit](List('D', 'o', 'm', 'a', 'i', 'n', 'H', 'i', 'e',
                                 'r', 'a', 'r', 'c', 'h', 'y'),
                            target_focus, default_node_properties,
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => datatype_DomainHierarchy.domainName) =>
                                eval_model[A](a, b),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => datatype_DomainHierarchy.domainName) =>
                                (c: datatype_DomainHierarchy.domainTree) =>
                                  verify_globals[A](a, b, c),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => datatype_DomainHierarchy.domainName) =>
                                domainHierarchy_offending_list[A](a, b),
                            (a: NetworkModel_Interface.networkModel_Params_ext[A,
datatype_DomainHierarchy.domainName, datatype_DomainHierarchy.domainTree, Unit])
                              => netModel_node_props[A,
              datatype_DomainHierarchy.domainTree, Unit](a),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: NetworkModel_Interface.networkModel_Params_ext[A,
  datatype_DomainHierarchy.domainName, datatype_DomainHierarchy.domainTree,
  Unit])
                                => domainHierarchy_eval[A](a, b),
                            ())

} /* object NM_DomainHierarchy */

object NM_NonInterference {

abstract sealed class node_config
final case class Interfering() extends node_config
final case class Unrelated() extends node_config

def target_focus: Boolean = true

def undirected_reachable[A : HOL.equal](g:
  FiniteListGraph.list_graph_ext[A, Unit],
 v: A):
      List[A] =
  Lista.removeAll[A](v, FiniteListGraph.succ_tran[A](FiniteListGraph.undirected[A](g),
              v))

def equal_node_configa(x0: node_config, x1: node_config): Boolean = (x0, x1)
  match {
  case (Unrelated(), Interfering()) => false
  case (Interfering(), Unrelated()) => false
  case (Unrelated(), Unrelated()) => true
  case (Interfering(), Interfering()) => true
}

implicit def equal_node_config: HOL.equal[node_config] = new
  HOL.equal[node_config] {
  val `HOL.equal` = (a: node_config, b: node_config) => equal_node_configa(a, b)
}

def eval_model[A : HOL.equal](g: FiniteListGraph.list_graph_ext[A, Unit],
                               nP: A => node_config):
      Boolean =
  Lista.list_all[A]((n: A) =>
                      (if (equal_node_configa(nP(n), Interfering()))
                        {
                          val result: List[node_config] =
                            Lista.remdups[node_config](Lista.map[A,
                          node_config](nP, undirected_reachable[A](g, n)));
                          Lista.nulla[node_config](result) ||
                            Lista.equal_list[node_config](result,
                   List(Unrelated()))
                        }
                        else true),
                     FiniteListGraph.nodesL[A, Unit](g))

def verify_globals[A](uu: FiniteListGraph.list_graph_ext[A, Unit],
                       uv: A => node_config, uw: Unit):
      Boolean =
  true

def default_node_properties: node_config = Interfering()

def netModel_node_props[A : NetworkModel_Vertices.vertex, B,
                         C](p: NetworkModel_Interface.networkModel_Params_ext[A,
                                       node_config, B, C]):
      A => node_config =
  (i: A) =>
    ((NetworkModel_Interface.node_properties[A, node_config, B, C](p)).apply(i)
       match {
       case None => default_node_properties
       case Some(property) => property
     })

def nonInterference_eval[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder](g:
              FiniteListGraph.list_graph_ext[A, Unit],
             p: NetworkModel_Interface.networkModel_Params_ext[A, node_config,
                        Unit, Unit]):
      Boolean =
  FiniteListGraph.valid_list_graph[A](g) &&
    (verify_globals[A](g, netModel_node_props[A, Unit, Unit](p),
                        NetworkModel_Interface.model_global_properties[A,
                                node_config, Unit, Unit](p)) &&
      eval_model[A](g, netModel_node_props[A, Unit, Unit](p)))

def nonInterference_offending_list[A : HOL.equal]:
      (FiniteListGraph.list_graph_ext[A, Unit]) =>
        (A => node_config) => List[List[(A, A)]] =
  (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
    (b: A => node_config) =>
      NetworkModel_Lists_Impl_Interface.generic_offending_list[A,
                        node_config]((aa:
FiniteListGraph.list_graph_ext[A, Unit])
                                       => (ba: A => node_config) =>
    eval_model[A](aa, ba),
                                      a, b)

def nM_LIB_NonInterference[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder]:
      NetworkModel_Lists_Impl_Interface.networkModel_packed_ext[A, node_config,
                         Unit, Unit] =
  NetworkModel_Lists_Impl_Interface.NetworkModel_packed_ext[node_config, A,
                     Unit,
                     Unit](List('N', 'o', 'n', 'I', 'n', 't', 'e', 'r', 'f',
                                 'e', 'r', 'e', 'n', 'c', 'e'),
                            target_focus, default_node_properties,
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => node_config) => eval_model[A](a, b),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => node_config) =>
                                (c: Unit) => verify_globals[A](a, b, c),
                            nonInterference_offending_list[A],
                            (a: NetworkModel_Interface.networkModel_Params_ext[A,
node_config, Unit, Unit])
                              => netModel_node_props[A, Unit, Unit](a),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: NetworkModel_Interface.networkModel_Params_ext[A,
  node_config, Unit, Unit])
                                => nonInterference_eval[A](a, b),
                            ())

} /* object NM_NonInterference */

object NM_SecurityGateway {

abstract sealed class secgw_member
final case class SecurityGateway() extends secgw_member
final case class DomainMember() extends secgw_member
final case class Unassigned() extends secgw_member

def target_focus: Boolean = false

def allowed_secgw_flow(x0: secgw_member, uu: secgw_member): Boolean = (x0, uu)
  match {
  case (SecurityGateway(), uu) => true
  case (DomainMember(), SecurityGateway()) => true
  case (DomainMember(), DomainMember()) => false
  case (DomainMember(), Unassigned()) => true
  case (Unassigned(), Unassigned()) => true
  case (Unassigned(), SecurityGateway()) => false
  case (Unassigned(), DomainMember()) => false
}

def eval_model[A : HOL.equal](g: FiniteListGraph.list_graph_ext[A, Unit],
                               nP: A => secgw_member):
      Boolean =
  Lista.list_all[(A, A)]((a: (A, A)) =>
                           {
                             val (e1, e2): (A, A) = a;
                             (if (! (HOL.eq[A](e1, e2)))
                               allowed_secgw_flow(nP(e1), nP(e2)) else true)
                           },
                          FiniteListGraph.edgesL[A, Unit](g))

def verify_globals[A](uu: FiniteListGraph.list_graph_ext[A, Unit],
                       uv: A => secgw_member, uw: Unit):
      Boolean =
  true

def default_node_properties: secgw_member = Unassigned()

def netModel_node_props[A : NetworkModel_Vertices.vertex, B,
                         C](p: NetworkModel_Interface.networkModel_Params_ext[A,
                                       secgw_member, B, C]):
      A => secgw_member =
  (i: A) =>
    ((NetworkModel_Interface.node_properties[A, secgw_member, B, C](p)).apply(i)
       match {
       case None => default_node_properties
       case Some(property) => property
     })

def securityGateway_eval[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder](g:
              FiniteListGraph.list_graph_ext[A, Unit],
             p: NetworkModel_Interface.networkModel_Params_ext[A, secgw_member,
                        Unit, Unit]):
      Boolean =
  FiniteListGraph.valid_list_graph[A](g) &&
    (verify_globals[A](g, netModel_node_props[A, Unit, Unit](p),
                        NetworkModel_Interface.model_global_properties[A,
                                secgw_member, Unit, Unit](p)) &&
      eval_model[A](g, netModel_node_props[A, Unit, Unit](p)))

def securityGateway_offending_list[A : HOL.equal](g:
            FiniteListGraph.list_graph_ext[A, Unit],
           nP: A => secgw_member):
      List[List[(A, A)]] =
  (if (eval_model[A](g, nP)) Nil
    else List(Lista.filter[(A, A)]((a: (A, A)) =>
                                     {
                                       val (e1, e2): (A, A) = a;
                                       ! (HOL.eq[A](e1, e2)) &&
 ! (allowed_secgw_flow(nP(e1), nP(e2)))
                                     },
                                    FiniteListGraph.edgesL[A, Unit](g))))

def nM_LIB_SecurityGateway[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder]:
      NetworkModel_Lists_Impl_Interface.networkModel_packed_ext[A, secgw_member,
                         Unit, Unit] =
  NetworkModel_Lists_Impl_Interface.NetworkModel_packed_ext[secgw_member, A,
                     Unit,
                     Unit](List('S', 'e', 'c', 'u', 'r', 'i', 't', 'y', 'G',
                                 'a', 't', 'e', 'w', 'a', 'y'),
                            target_focus, default_node_properties,
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => secgw_member) => eval_model[A](a, b),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => secgw_member) =>
                                (c: Unit) => verify_globals[A](a, b, c),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => secgw_member) =>
                                securityGateway_offending_list[A](a, b),
                            (a: NetworkModel_Interface.networkModel_Params_ext[A,
secgw_member, Unit, Unit])
                              => netModel_node_props[A, Unit, Unit](a),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: NetworkModel_Interface.networkModel_Params_ext[A,
  secgw_member, Unit, Unit])
                                => securityGateway_eval[A](a, b),
                            ())

} /* object NM_SecurityGateway */

object NM_DomainHierarchyTE {

abstract sealed class node_config_ext[A]
final case class
  Node_config_ext[A](a: datatype_DomainHierarchy.domainName, b: Nat.nat, c: A)
  extends node_config_ext[A]

def level[A](x0: node_config_ext[A]): datatype_DomainHierarchy.domainName = x0
  match {
  case Node_config_ext(level, trust, more) => level
}

def trust[A](x0: node_config_ext[A]): Nat.nat = x0 match {
  case Node_config_ext(level, trust, more) => trust
}

def target_focus: Boolean = false

def domainNameChopOne(x0: datatype_DomainHierarchy.domainName):
      datatype_DomainHierarchy.domainName =
  x0 match {
  case datatype_DomainHierarchy.Unassigned() => datatype_DomainHierarchy.Leaf()
  case datatype_DomainHierarchy.Leaf() => datatype_DomainHierarchy.Leaf()
  case datatype_DomainHierarchy.Dept(name, datatype_DomainHierarchy.Leaf()) =>
    datatype_DomainHierarchy.Leaf()
  case datatype_DomainHierarchy.Dept(name, datatype_DomainHierarchy.Dept(v, va))
    => datatype_DomainHierarchy.Dept(name,
                                      domainNameChopOne(datatype_DomainHierarchy.Dept(v,
       va)))
  case datatype_DomainHierarchy.Dept(name,
                                      datatype_DomainHierarchy.Unassigned())
    => datatype_DomainHierarchy.Dept(name,
                                      domainNameChopOne(datatype_DomainHierarchy.Unassigned()))
}

def domainNameChop(x0: datatype_DomainHierarchy.domainName, uv: Nat.nat):
      datatype_DomainHierarchy.domainName =
  (x0, uv) match {
  case (datatype_DomainHierarchy.Leaf(), uv) => datatype_DomainHierarchy.Leaf()
  case (datatype_DomainHierarchy.Unassigned(), v) =>
    (if (Nat.equal_nat(v, Nat.zero_nat)) datatype_DomainHierarchy.Unassigned()
      else datatype_DomainHierarchy.Leaf())
  case (datatype_DomainHierarchy.Dept(v, va), n) =>
    (if (Nat.equal_nat(n, Nat.zero_nat)) datatype_DomainHierarchy.Dept(v, va)
      else domainNameChop(domainNameChopOne(datatype_DomainHierarchy.Dept(v,
                                   va)),
                           Nat.minus_nat(n, Nat.one_nat)))
}

def eval_model[A](g: FiniteListGraph.list_graph_ext[A, Unit],
                   nP: A => node_config_ext[Unit]):
      Boolean =
  Lista.list_all[(A, A)]((a: (A, A)) =>
                           {
                             val (e1, e2): (A, A) = a
                             val c1: node_config_ext[Unit] = nP(e1);
                             datatype_DomainHierarchy.less_eq_domainName(level[Unit](nP(e2)),
                                  domainNameChop(level[Unit](c1),
          trust[Unit](c1)))
                           },
                          FiniteListGraph.edgesL[A, Unit](g))

def verify_globals[A](g: FiniteListGraph.list_graph_ext[A, Unit],
                       nP: A => node_config_ext[Unit],
                       tree: datatype_DomainHierarchy.domainTree):
      Boolean =
  Lista.list_all[A]((v: A) =>
                      datatype_DomainHierarchy.valid_hierarchy_pos(tree,
                            level[Unit](nP(v))) &&
                        (if (datatype_DomainHierarchy.equal_domainName(level[Unit](nP(v)),
                                datatype_DomainHierarchy.Unassigned()))
                          Nat.equal_nat(trust[Unit](nP(v)), Nat.zero_nat)
                          else true),
                     FiniteListGraph.nodesL[A, Unit](g))

def default_node_properties: node_config_ext[Unit] =
  Node_config_ext[Unit](datatype_DomainHierarchy.Unassigned(), Nat.zero_nat, ())

def netModel_node_props[A : NetworkModel_Vertices.vertex, B,
                         C](p: NetworkModel_Interface.networkModel_Params_ext[A,
                                       node_config_ext[Unit], B, C]):
      A => node_config_ext[Unit] =
  (i: A) =>
    ((NetworkModel_Interface.node_properties[A, node_config_ext[Unit], B,
      C](p)).apply(i)
       match {
       case None => default_node_properties
       case Some(property) => property
     })

def domainHierarchyTE_eval[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder](g:
                FiniteListGraph.list_graph_ext[A, Unit],
               p: NetworkModel_Interface.networkModel_Params_ext[A,
                          node_config_ext[Unit],
                          datatype_DomainHierarchy.domainTree, Unit]):
      Boolean =
  FiniteListGraph.valid_list_graph[A](g) &&
    (verify_globals[A](g, netModel_node_props[A,
       datatype_DomainHierarchy.domainTree, Unit](p),
                        NetworkModel_Interface.model_global_properties[A,
                                node_config_ext[Unit],
                                datatype_DomainHierarchy.domainTree,
                                Unit](p)) &&
      eval_model[A](g, netModel_node_props[A,
    datatype_DomainHierarchy.domainTree, Unit](p)))

def domainHierarchyTE_offending_list[A](g:
  FiniteListGraph.list_graph_ext[A, Unit],
 nP: A => node_config_ext[Unit]):
      List[List[(A, A)]] =
  (if (eval_model[A](g, nP)) Nil
    else List(Lista.filter[(A, A)]((a: (A, A)) =>
                                     {
                                       val (e1, e2): (A, A) = a
                                       val c1: node_config_ext[Unit] = nP(e1);
                                       ! (datatype_DomainHierarchy.less_eq_domainName(level[Unit](nP(e2)),
       domainNameChop(level[Unit](c1), trust[Unit](c1))))
                                     },
                                    FiniteListGraph.edgesL[A, Unit](g))))

def nM_LIB_DomainHierarchyTE[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder]:
      NetworkModel_Lists_Impl_Interface.networkModel_packed_ext[A,
                         node_config_ext[Unit],
                         datatype_DomainHierarchy.domainTree, Unit] =
  NetworkModel_Lists_Impl_Interface.NetworkModel_packed_ext[node_config_ext[Unit],
                     A, datatype_DomainHierarchy.domainTree,
                     Unit](List('D', 'o', 'm', 'a', 'i', 'n', 'H', 'i', 'e',
                                 'r', 'a', 'r', 'c', 'h', 'y', 'T', 'E'),
                            target_focus, default_node_properties,
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => node_config_ext[Unit]) =>
                                eval_model[A](a, b),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => node_config_ext[Unit]) =>
                                (c: datatype_DomainHierarchy.domainTree) =>
                                  verify_globals[A](a, b, c),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => node_config_ext[Unit]) =>
                                domainHierarchyTE_offending_list[A](a, b),
                            (a: NetworkModel_Interface.networkModel_Params_ext[A,
node_config_ext[Unit], datatype_DomainHierarchy.domainTree, Unit])
                              => netModel_node_props[A,
              datatype_DomainHierarchy.domainTree, Unit](a),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: NetworkModel_Interface.networkModel_Params_ext[A,
  node_config_ext[Unit], datatype_DomainHierarchy.domainTree, Unit])
                                => domainHierarchyTE_eval[A](a, b),
                            ())

} /* object NM_DomainHierarchyTE */

object NetworkModel_Library {

import /*implicits*/ NetworkModel_Vertices.linorder_vString,
  NetworkModel_Vertices.vertex_vString, NetworkModel_Vertices.equal_vString

def bLPexample1: Boolean =
  (NetworkModel_Lists_Impl_Interface.nm_eval[NetworkModel_Vertices.vString,
      Nat.nat, Unit,
      Unit](NM_BLPbasic.nM_LIB_BLPbasic[NetworkModel_Vertices.vString])).apply(NM_BLPbasic.fabNet).apply(NetworkModel_Interface.NetworkModel_Params_ext[NetworkModel_Vertices.vString,
                                 Nat.nat, Unit,
                                 Unit](Fun.fun_upd[NetworkModel_Vertices.vString,
            Option[Nat.nat]](Fun.fun_upd[NetworkModel_Vertices.vString,
  Option[Nat.nat]](Fun.fun_upd[NetworkModel_Vertices.vString,
                                Option[Nat.nat]](Fun.fun_upd[NetworkModel_Vertices.vString,
                      Option[Nat.nat]]((_: NetworkModel_Vertices.vString) =>
 None,
NetworkModel_Vertices.V(List('P', 'r', 'e', 's', 'e', 'n', 'c', 'e', 'S', 'e',
                              'n', 's', 'o', 'r')),
Some[Nat.nat](Code_Numeral.nat_of_integer(BigInt(2)))),
          NetworkModel_Vertices.V(List('W', 'e', 'b', 'c', 'a', 'm')),
          Some[Nat.nat](Code_Numeral.nat_of_integer(BigInt(3)))),
                    NetworkModel_Vertices.V(List('S', 'e', 'n', 's', 'o', 'r',
          'S', 'i', 'n', 'k')),
                    Some[Nat.nat](Code_Numeral.nat_of_integer(BigInt(3)))),
                              NetworkModel_Vertices.V(List('S', 't', 'a', 't',
                    'i', 's', 't', 'i', 'c', 's')),
                              Some[Nat.nat](Code_Numeral.nat_of_integer(BigInt(3)))),
(), ()))

def bLPexample3:
      List[List[(NetworkModel_Vertices.vString,
                  NetworkModel_Vertices.vString)]] =
  (NetworkModel_Lists_Impl_Interface.nm_offending_flows[NetworkModel_Vertices.vString,
                 Nat.nat, Unit,
                 Unit](NM_BLPbasic.nM_LIB_BLPbasic[NetworkModel_Vertices.vString])).apply(NM_BLPbasic.fabNet).apply((NetworkModel_Lists_Impl_Interface.nm_node_props[NetworkModel_Vertices.vString,
      Nat.nat, Unit,
      Unit](NM_BLPbasic.nM_LIB_BLPbasic[NetworkModel_Vertices.vString])).apply(NM_BLPbasic.sensorProps_NMParams_try3))

} /* object NetworkModel_Library */

object NM_CommunicationPartners {

abstract sealed class node_config[A]
final case class DontCare[A]() extends node_config[A]
final case class Care[A]() extends node_config[A]
final case class Master[A](a: List[A]) extends node_config[A]

def allowed_flow[A : HOL.equal](x0: node_config[A], s: A, x2: node_config[A],
                                 r: A):
      Boolean =
  (x0, s, x2, r) match {
  case (DontCare(), s, DontCare(), r) => true
  case (DontCare(), s, Care(), r) => true
  case (DontCare(), s, Master(uu), r) => false
  case (Care(), s, Care(), r) => true
  case (Care(), s, DontCare(), r) => true
  case (Care(), s, Master(m), r) => Lista.member[A](m, s)
  case (Master(uv), s, Master(m), r) => Lista.member[A](m, s)
  case (Master(uw), s, Care(), r) => true
  case (Master(ux), s, DontCare(), r) => true
}

def target_focus: Boolean = false

def eval_model[A : HOL.equal](g: FiniteListGraph.list_graph_ext[A, Unit],
                               nP: A => node_config[A]):
      Boolean =
  Lista.list_all[(A, A)]((a: (A, A)) =>
                           {
                             val (s, r): (A, A) = a;
                             (if (! (HOL.eq[A](s, r)))
                               allowed_flow[A](nP(s), s, nP(r), r) else true)
                           },
                          FiniteListGraph.edgesL[A, Unit](g))

def verify_globals[A](uu: FiniteListGraph.list_graph_ext[A, Unit],
                       uv: A => node_config[A], uw: Unit):
      Boolean =
  true

def default_node_properties[A]: node_config[A] = DontCare[A]()

def netModel_node_props[A : NetworkModel_Vertices.vertex,
                         B](p: NetworkModel_Interface.networkModel_Params_ext[A,
                                       node_config[A], B, Unit]):
      A => node_config[A] =
  (i: A) =>
    ((NetworkModel_Interface.node_properties[A, node_config[A], B,
      Unit](p)).apply(i)
       match {
       case None => default_node_properties[A]
       case Some(property) => property
     })

def communicationPartners_eval[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder](g:
                    FiniteListGraph.list_graph_ext[A, Unit],
                   p: NetworkModel_Interface.networkModel_Params_ext[A,
                              node_config[A], Unit, Unit]):
      Boolean =
  FiniteListGraph.valid_list_graph[A](g) &&
    (verify_globals[A](g, netModel_node_props[A, Unit](p),
                        NetworkModel_Interface.model_global_properties[A,
                                node_config[A], Unit, Unit](p)) &&
      eval_model[A](g, netModel_node_props[A, Unit](p)))

def communicationPartners_offending_list[A : HOL.equal](g:
                  FiniteListGraph.list_graph_ext[A, Unit],
                 nP: A => node_config[A]):
      List[List[(A, A)]] =
  (if (eval_model[A](g, nP)) Nil
    else List(Lista.filter[(A, A)]((a: (A, A)) =>
                                     {
                                       val (e1, e2): (A, A) = a;
                                       ! (HOL.eq[A](e1, e2)) &&
 ! (allowed_flow[A](nP(e1), e1, nP(e2), e2))
                                     },
                                    FiniteListGraph.edgesL[A, Unit](g))))

def nM_LIB_CommunicationPartners[A : HOL.equal : NetworkModel_Vertices.vertex : Orderings.linorder]:
      NetworkModel_Lists_Impl_Interface.networkModel_packed_ext[A,
                         node_config[A], Unit, Unit] =
  NetworkModel_Lists_Impl_Interface.NetworkModel_packed_ext[node_config[A], A,
                     Unit,
                     Unit](List('C', 'o', 'm', 'm', 'u', 'n', 'i', 'c', 'a',
                                 't', 'i', 'o', 'n', 'P', 'a', 'r', 't', 'n',
                                 'e', 'r', 's'),
                            target_focus, default_node_properties[A],
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => node_config[A]) => eval_model[A](a, b),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => node_config[A]) =>
                                (c: Unit) => verify_globals[A](a, b, c),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: A => node_config[A]) =>
                                communicationPartners_offending_list[A](a, b),
                            (a: NetworkModel_Interface.networkModel_Params_ext[A,
node_config[A], Unit, Unit])
                              => netModel_node_props[A, Unit](a),
                            (a: FiniteListGraph.list_graph_ext[A, Unit]) =>
                              (b: NetworkModel_Interface.networkModel_Params_ext[A,
  node_config[A], Unit, Unit])
                                => communicationPartners_eval[A](a, b),
                            ())

} /* object NM_CommunicationPartners */
